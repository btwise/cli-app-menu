# Â©2018 Copyright 2018 Robert D. Chin
#
# +----------------------------------------+
# |             Revision Date              |
# +----------------------------------------+
# REVDATE="July-30-2018 88:88"
#
# +----------------------------------------+
# |        Function f_menu_setup           |
# +----------------------------------------+
#
#  Inputs: $1=File containing menu options to build the menu options array.
#          $2=Temporary file that is generated which displays the Menu.
#          $3=Title of Menu.
#          $MAX_LENGTH $MAX_LINES $MAX_CHOICE_LENGTH
#    Uses: None.
# Outputs: MAX_CHOICE_LENGTH. arrays CHOICE(n), SUMMARY(n), FUNC(n). 
#
f_menu_setup () { # Create the arrays for the menu options and display the Menu.
      f_menu_arrays $1
      f_create_show_menu $GUI $2 $3 $MAX_LENGTH $MAX_LINES $MAX_CHOICE_LENGTH
} # End of function f_menu_setup.
#
# +----------------------------------------+
# |      Function f_app_menu_setup         |
# +----------------------------------------+
#
#  Inputs: $1=File containing menu options to build the menu options array.
#          $2=Temporary file that is generated which displays the Menu.
#          $3=Title of Menu.
#          $4=$DELIMITER
#          $MAX_LENGTH $MAX_LINES $MAX_CHOICE_LENGTH
#    Uses: None.
# Outputs: MAX_CHOICE_LENGTH. arrays CHOICE(n), SUMMARY(n), FUNC(n). 
#
f_app_menu_setup () { # Create the arrays for the menu options and display the Menu.
      f_app_menu_arrays $1 $4
      f_create_show_menu $GUI $2 $3 $MAX_LENGTH $MAX_LINES $MAX_CHOICE_LENGTH
} # End of function f_menu_setup.
#
# +----------------------------------------+
# |        Function f_menu_arrays          |
# +----------------------------------------+
#
#  Inputs: $1=file of menu choice strings.
#    Uses: ARRAY_NUM, ARRAY_NAME, ARRAY_VALUE, TEMP_FILE, XSTR.
# Outputs: MAX, MAX_LINES, MAX_CHOICE_LENGTH. arrays CHOICE(n), SUMMARY(n), FUNC(n). 
#
f_menu_arrays () {
      # Create arrays CHOICE, SUMMARY, FUNC to store menu option information.
      #
      # Example:
      # Menu option name is "Directory Listing"
      # Shared directory to be mounted is "//hansolo/public/contacts"
      # Local PC mount-point is "/mnt/hansolo/contacts"
      #
      #     CHOICE[1]="Directory Listing"
      #     SUMMARY[1]="get a listing of files in a directory."
      #     FUNC[1]="f_dir_listing"     # Function to do command "ls -l".
      #
      unset CHOICE SUMMARY FUNC  # Delete arrays in memory.
      ARRAY_NUM=1
      TEMP_FILE="cli-app-menu_temp.tmp"
      #
      #                 Field-1 (null)  Field-2                      Field-3                     Field-4
      # Format of XSTR="<Delimiter> <Choice Title> <Delimiter> <Short Description> <Delimiter> <function>"
      #
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      #
      while read XSTR  # Read lines one at a time from file $1.
      do
            case $XSTR in
                  \#@@*) echo $XSTR >>$TEMP_FILE
                  ;;
            esac
      done < $1  # Read lines from file $1.
      #
      # Delete last line which is from the case statement pattern immediately above.
      sed -i /echo*/d $TEMP_FILE # Delete last line in $TEMP_FILE which is actual code not data.
      #
      # Calculate longest line length in TEMP_FILE to find maximum menu width for Dialog or Whiptail.
      # The "Word Count" wc command output will not include the TEMP_FILE name
      # when you redirect "<$TEMP_FILE" into wc.
      MAX_LENGTH=$(wc --max-line-length <$TEMP_FILE)
      #
      # Calculate number of lines or Menu Choices to find maximum menu lines for Dialog or Whiptail.
      MAX_LINES=$(wc --lines <$TEMP_FILE)
      MAX=$MAX_LINES
      #
      MAX_CHOICE_LENGTH=0
      #
      while read XSTR  # Read each line (starting with "#@@") of TEMP_FILE (extracted from file $1).
      do
            # Set array CHOICE[n] = <field-1> or "Choice Title" of XSTR.
            ARRAY_NAME="CHOICE"
            ARRAY_VALUE=$(echo $XSTR | awk -F "#@@" '{ if ( $3 ) { print $2 }}')
            ARRAY_VALUE=$(echo $ARRAY_VALUE | tr ' ' '_')
            eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
            #
            # Calculate length of next Menu Option Choice string.
                CHOICE_LENGTH=${#ARRAY_VALUE}
                # Save the value of the longest length of the Menu Option.
                if [ $CHOICE_LENGTH -gt $MAX_CHOICE_LENGTH ] ; then
                   # Save new maximum string length.
                   MAX_CHOICE_LENGTH=$CHOICE_LENGTH
                fi
            #
            # Set array SUMMARY[n]=<field-2> or "Summary" of XSTR.
            ARRAY_NAME="SUMMARY"
            ARRAY_VALUE=$(echo $XSTR | awk -F "#@@" '{ if ( $3 ) { print $3 }}')
            ARRAY_VALUE=$(echo $ARRAY_VALUE | tr ' ' '_')
            eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
            #
            # Set array $FUNC=<field-3> or "Function" of XSTR.
            ARRAY_NAME="FUNC"
            ARRAY_VALUE=$(echo $XSTR | awk -F "#@@" '{ if ( $3 ) { print $4 }}')
            ARRAY_VALUE=$(echo $ARRAY_VALUE | tr ' ' '_')
            eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
            #
            let ARRAY_NUM=$ARRAY_NUM+1
      done < $TEMP_FILE
      #
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      unset TEMP_FILE XSTR  # Throw out this variable.
} # End of f_menu_arrays.
#
# +----------------------------------------+
# |      Function f_app_menu_arrays        |
# +----------------------------------------+
#
#  Inputs: $1=file of menu choice strings.
#          $2=$DELIMITER.
#    Uses: ARRAY_NUM, ARRAY_NAME, ARRAY_VALUE, TEMP_FILE, XSTR.
# Outputs: MAX, MAX_LINES, MAX_CHOICE_LENGTH. arrays CHOICE(n), SUMMARY(n), FUNC(n). 
#
f_app_menu_arrays () {
      # Create arrays CHOICE, SUMMARY, FUNC to store menu option information.
      #
      # Example:
      # Menu option name is "Directory Listing"
      # Shared directory to be mounted is "//hansolo/public/contacts"
      # Local PC mount-point is "/mnt/hansolo/contacts"
      #
      #     CHOICE[1]="Directory Listing"
      #     SUMMARY[1]="get a listing of files in a directory."
      #
      unset CHOICE SUMMARY FUNC  # Delete arrays in memory.
      #
      #                 Field-1 (null)  Field-2                      Field-3
      # Format of XSTR="<Delimiter> <Choice Title> <Delimiter> <Short Description>
      #
      TEMP_FILE="cli-app-menu_temp.tmp"
      #
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      #
      while read XSTR  # Read lines one at a time from file $1.
      do
            case $XSTR in
                  *$2*) echo $XSTR >>$TEMP_FILE
                  ;;
            esac
      done < $1  # Read lines from file $1.
      #
      # Delete last line which is from the case statement pattern immediately above.
      sed -i '$ d' $TEMP_FILE # Delete last line in $TEMP_FILE which is actual code not data.
      # i.e. Delete last line "DELIMITER="#MAU" #MAU This 3rd field prevents awk from printing this line into menu options."
      #
      # Calculate longest line length in TEMP_FILE to find maximum menu width for Dialog or Whiptail.
      # The "Word Count" wc command output will not include the TEMP_FILE name
      # when you redirect "<$TEMP_FILE" into wc.
      MAX_LENGTH=$(wc --max-line-length <$TEMP_FILE)
      #
      # Calculate number of lines or Menu Choices to find maximum menu lines for Dialog or Whiptail.
      MAX_LINES=$(wc --lines <$TEMP_FILE)
      MAX=$MAX_LINES
      #
      MAX_CHOICE_LENGTH=0
      #
      ARRAY_NUM=1
      #
      ARRAY_NAME="CHOICE"
      ARRAY_VALUE="Exit"
      eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
      ARRAY_NAME="SUMMARY"
      ARRAY_VALUE="Go_back_to_the_previous_menu."
      eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
      ARRAY_NAME="FUNC"
      ARRAY_VALUE="break"
      eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
      let ARRAY_NUM=$ARRAY_NUM+1
      #
      while read XSTR  # Read each line (starting with "#@@") of TEMP_FILE (extracted from file $1).
      do
            # Set array CHOICE[n] = <field-1> or "Choice Title" of XSTR.
            ARRAY_NAME="CHOICE"
            ARRAY_VALUE=$(echo $XSTR | awk '{ print $3 }')
            ARRAY_VALUE=$(echo $ARRAY_VALUE | tr ' ' '_')
            eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
            #
            # Calculate length of next Menu Option Choice string.
                CHOICE_LENGTH=${#ARRAY_VALUE}
                # Save the value of the longest length of the Menu Option.
                if [ $CHOICE_LENGTH -gt $MAX_CHOICE_LENGTH ] ; then
                   # Save new maximum string length.
                   MAX_CHOICE_LENGTH=$CHOICE_LENGTH
                fi
            #
            # Set array SUMMARY[n]=<field-2> or "Summary" of XSTR.
            ARRAY_NAME="SUMMARY"
            ARRAY_VALUE=$(echo $XSTR | awk -F "- " '{ print $2 }')
            ARRAY_VALUE=$(echo $ARRAY_VALUE | tr ' ' '_')
            ARRAY_VALUE=$(echo $ARRAY_VALUE | tr '(' '_')  # Delete any parenthesis in Summary Description.
            ARRAY_VALUE=$(echo $ARRAY_VALUE | tr ')' '_')
            ARRAY_VALUE=$(echo $ARRAY_VALUE | tr '__' '_')
            eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
            #
            # Set array $FUNC=<field-3> or "Function" of XSTR.
            ARRAY_NAME="FUNC"
            ARRAY_VALUE="f_app_process"  # All application menu choices use this function.
            eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
            #
            let ARRAY_NUM=$ARRAY_NUM+1
      done < $TEMP_FILE
      #
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      unset TEMP_FILE XSTR  # Throw out this variable.
} # End of f_app_menu_arrays.
#
# +----------------------------------------+
# |          Function f_app_process        |
# +----------------------------------------+
#
#  Inputs: CHOICE
#    Uses: GENERATED_FILE, ARRAY_NAME, ARRAY_LEN, XNUM.
# Outputs: None.
#
f_app_process () {
      # This function is in the case statment in f_menu_txt, f_menu_gui of
      # file "cliappmenu_generated.tmp" and is used for all application menus.
      # This function is needed because the case statement does not allow
      # the passing of function parameters.
      #
      case $CHOICE in
           [0-9] | [0-9][0-9]) # If CHOICE is a number, then add 1 to increment by 1.
           let CHOICE=$CHOICE+1  # In the App Menu, CHOICE=0 to exit, but CHOICE Array CHOICE[1]=Exit Menu so if CHOICE=0, make it CHOICE=1.
#echo -n "Before f_menu_item_process CHOICE=$CHOICE"; read X ; unset X  # Diagnostic Line.
           ;;
      esac
      f_menu_item_process $CHOICE  # Outputs $MENU_ITEM.
      #
} # End of f_app_menu_arrays.
#
# +----------------------------------------+
# |       Function f_create_show_menu      |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=GENERATED_FILE.
#          $3=Menu Title.
#          $4=MAX_LENGTH.
#          $5=MAX_LINES.
#          $6=MAX_CHOICE_LENGTH
#    Uses: GENERATED_FILE, ARRAY_NAME, ARRAY_LEN, XNUM.
# Outputs: None.
#
f_create_show_menu () {
      if [ ! -r "/$THIS_DIR/EDIT_HISTORY" ] ; then
         PROJECT_REVISION="Unknown, edit history is unavailable."
         PROJECT_REVDATE="Unknown, edit history is unavailable."
      else
         PROJECT_REVISION=$(grep ^PROJECT_REVISION "/$THIS_DIR/EDIT_HISTORY" | awk -F "=" '{ print $2 }' | awk -F '"' '{print $2}')
         PROJECT_REVDATE=$(grep ^PROJECT_REVDATE= "/$THIS_DIR/EDIT_HISTORY" | awk -F "=" '{ print $2 }' | awk -F '"' '{print $2}')
      fi
     case $1 in
           "dialog" | "whiptail")
           f_update_menu_gui $1 $2 $3 $4 $5
           ;;
           "text")
           f_update_menu_txt $1 $2 $3 $6
           ;;
      esac
      #
      . $2  # Invoke Generated file.
      #
      # Use generated menu script to display menu.
      case $1 in
           "dialog" | "whiptail") 
           f_menu_gui $1 $3  # function resides in generated file $GENERATED_FILE created by f_update_menu_gui.
           ;;
           "text")
           f_menu_txt  # function resides in generated file $GENERATED_FILE created by f_update_menu_txt.
           ;;
       esac
      #
      if [ -r $2 ] ; then
         rm $2
      fi
} # End of function f_create_show_menu.
#
# +----------------------------------------+
# |        Function f_update_menu_txt      |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=GENERATED_FILE.
#          $3=Menu Title.
#          $4=MAX_CHOICE_LENGTH.
#          ARRAY_FILE name of file containing Menu structure information:
#                     Choice Title, Short Description, function.
#          THIS_DIR, PROJECT_REVISION, PROJECT_REVDATE, MENU_TITLE.
#    Uses: X, Y, XNUM, YNUM, ARRAY_NAME, ARRAY_LEN, PAD, CHOICE. MENU_TITLE, SUMMARY, FUNC.
# Outputs: None.
#
f_update_menu_txt () {
      echo "#!/bin/bash" >$2
      echo "#" >>$2
      echo "# Â©2018 Copyright 2018 Robert D. Chin" >>$2
      echo "#" >>$2
      echo "# Usage: bash menu.sh" >>$2
      echo "#        (not sh menu.sh)" >>$2
      echo "#" >>$2
      echo "# Project Version: $PROJECT_REVISION" >>$2
      echo "#  Last Edited on: $PROJECT_REVDATE" >>$2
      echo "#" >>$2
      echo "#***********************************CAUTION***********************************" >>$2
      echo "# Any edits made to this code will be lost since this code is" >>$2
      echo "# automatically generated and updated by running the script," >>$2
      echo "# \"menu.sh\" which contains data for the menu." >>$2
      echo "#***********************************CAUTION***********************************" >>$2
      echo "#" >>$2
      echo "# +----------------------------------------+" >>$2
      echo "# |           Function f_menu_txt          |" >>$2
      echo "# +----------------------------------------+" >>$2
      echo "#" >>$2
      echo "#  Inputs: $1=GUI" >>$2
      echo "#    Uses: X, MENU_TITLE, ARRAY_NAME, ARRAY_LEN, CHOICE, SUMMARY, FUNC." >>$2
      echo "# Outputs: None." >>$2
      echo "#" >>$2
      echo "f_menu_txt () {" >>$2
      echo "      . $ARRAY_FILE   # invoke the necessary files. This comes from ARRAY_FILE." >>$2
      echo "      . $THIS_DIR/lib_cli-common.lib" >>$2
      echo "      #" >>$2
      echo "      f_main_config" >>$2
      echo "      f_term_color $FCOLOR $BCOLOR # Set terminal color." >>$2
      echo "      echo \"\$(tput bold)\" # set bold font." >>$2
      echo "      #" >>$2
      echo "      CHOICE=\"\"  # Initialize variable." >>$2
      echo "      until [ \"\$CHOICE\" = \"QUIT\" ]" >>$2
      echo "            do    # Start of menu until loop." >>$2
      echo "               clear  #Clear screen." >>$2
      MENU_TITLE=$(echo $3 | tr '_' ' ') # Do not redirect the output of this line by doing ">>$2".
      echo "               MENU_TITLE=\"$MENU_TITLE\"" >>$2
      echo "               echo \"               \$MENU_TITLE\"; echo" >>$2
      #
      # Get display screen or window size to get maximum width.
      # Get the screen resolution or X-window size.
      # Get rows (height).
      Y=$(stty size | awk '{ print $1 }')
      # Get columns (width).
      X=$(stty size | awk '{ print $2 }')
      #
      # Read both CHOICE and SUMMARY arrays and format strings to display
      # in a pretty formatted menu.
      ARRAY_NAME="CHOICE"
      ARRAY_LEN=$(eval "echo \$\{#$ARRAY_NAME[@]\}")
      ARRAY_LEN=$(eval echo $ARRAY_LEN)
      TEMP_FILE="cli-app-menu_temp.tmp"
      #
      for (( XNUM=1; XNUM<=${ARRAY_LEN}; XNUM++ ));
          do
             ARRAY_NAME="CHOICE"
             CHOICE=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
             CHOICE=$(eval echo $CHOICE)
             CHOICE=$(echo $CHOICE | tr '_' ' ')
             # CHOICE_LC is a lower-case CHOICE string for the purpose of easier pattern matching in a case statement.
             CHOICE_LC=$(echo $CHOICE | tr \'[:upper:]\' \'[:lower:]\')
             #
             ARRAY_NAME="SUMMARY"
             SUMMARY=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
             SUMMARY=$(eval echo $SUMMARY)
             SUMMARY=$(echo $SUMMARY | tr '_' ' ')
             #
             ARRAY_NAME="FUNC"
             FUNC=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
             FUNC=$(eval echo $FUNC)
             #
             let YNUM=$XNUM-1  # Start numbering choices from zero so zero selects CHOICE[1]
             #
             # Save the pattern matching for the case statement which is later inserted into the function, "f_menu_txt".
             echo "                    $YNUM | \"${CHOICE_LC:0:1}\" | \"${CHOICE_LC:0:2}\" | \"${CHOICE_LC:0:3}\" | \"${CHOICE_LC:0:4}\" | \"${CHOICE_LC:0:5}\" | \"${CHOICE_LC:0:6}\" | \"${CHOICE_LC:0:7}\" | \"${CHOICE_LC:0:8}\" | \"${CHOICE_LC:0:9}\" | \"${CHOICE_LC:0:10}\" | \"${CHOICE_LC:0:11}\" | \"${CHOICE_LC:0:12}\" | \"${CHOICE_LC:0:13}\" | \"${CHOICE_LC:0:14}\" | \"${CHOICE_LC:0:15}\"* | \"man ${CHOICE_LC:0:15}\"*) $FUNC  ;;" >>$TEMP_FILE
             #
             if [ -n "$CHOICE" ] ; then
                # Read next Menu Option Choice string and get its string length.
                CHOICE_LENGTH=${#CHOICE}
                if [ $CHOICE_LENGTH -lt $4 ] ; then
                   let PAD=$4-$CHOICE_LENGTH
                   until [ $PAD -eq 0 ]
                   do
                      # Pad spaces to right (left-justify CHOICE).
                      # CHOICE     - Summary description.
                      CHOICE=$CHOICE" "
                      #
                      # Pad spaces to left (right-justify CHOICE).
                      #     CHOICE - Summary description.
                      #CHOICE=" "$CHOICE
                      #
                      let PAD=$PAD-1
                   done
                fi
                # Truncate "CHOICE - Summary description"
                # if longer than maximum window or screen width.
                #
                # Example: "$YNUM $CHOICE - $SUMMARY"
                # CHOICE="0 Quit - Quit to command-line prompt." where array CHOICE[1]="Quit"
                CHOICE="$YNUM $CHOICE - $SUMMARY"
                CHOICE_LENGTH=${#CHOICE}
                # Is the length of string CHOICE plus SUMMARY > Maximum window width?
                if [ $CHOICE_LENGTH -gt $X ] ; then
                   # Yes, truncate SUMMARY length to fit maximum window or screen width.
                   let X=$X-3
                   CHOICE=${CHOICE:0:$X}"..."
                fi
                # No, leave length alone, just print to screen.
                echo "               echo \"$CHOICE\"" >>$2
             fi
          done
      echo "               echo" >>$2
      echo "               echo -n \" Enter 0-$YNUM or letters (0): \" ; read CHOICE" >>$2
      echo "               #CHOICE Convert to lower-case." >>$2
      echo "               CHOICE=\$(echo \$CHOICE | tr \'[:upper:]\' \'[:lower:]\')" >>$2
      echo "               #" >>$2
      echo "               case \$CHOICE in" >>$2
      echo "                    \"\") CHOICE=\"QUIT\" ;;  # Set default choice pattern match." >>$2
      # Case pattern matching statements are read from TEMP_FILE to be included here.
      cat $TEMP_FILE >>$2
      echo "               esac" >>$2
      echo "           done" >>$2
      echo "       unset MENU_TITLE CHOICE  # Throw out this variable." >>$2
      echo "       #" >>$2
      echo "       } # End of function f_menu_txt." >>$2
      #
      # Remove $TEMP_FILE.
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      unset X Y XNUM YNUM MENU_TITLE ARRAY_NAME ARRAY_LEN  # CHOICE SUMMARY FUNC
} # End of function f_update_menu_txt.
#
# +----------------------------------------+
# |        Function f_update_menu_gui      |
# +----------------------------------------+
#
#  Inputs: $1=GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2=GENERATED_FILE.
#          $3=Menu Title.
#          $4=MAX_LENGTH
#          $5=MAX_LINES
#    Uses: GENERATED_FILE, ARRAY_NAME, ARRAY_LEN, XNUM.
# Outputs: None.
#
f_update_menu_gui () {
      echo "#!/bin/bash" >$2
      echo "#" >>$2
      echo "# Â©2018 Copyright 2018 Robert D. Chin" >>$2
      echo "#" >>$2
      echo "# Usage: bash menu.sh" >>$2
      echo "#        (not sh menu.sh)" >>$2
      echo "#" >>$2
      echo "# Project Version: $PROJECT_REVISION" >>$2
      echo "#  Last Edited on: $PROJECT_REVDATE" >>$2
      echo "#" >>$2
      echo "#***********************************CAUTION***********************************" >>$2
      echo "# Any edits made to this code will be lost since this code is" >>$2
      echo "# automatically generated and updated by running the script," >>$2
      echo "# \"menu.sh\" which contains data for the Main menu." >>$2
      echo "#***********************************CAUTION***********************************" >>$2
      echo "#" >>$2
      echo "# +----------------------------------------+" >>$2
      echo "# |           Function f_menu_gui          |" >>$2
      echo "# +----------------------------------------+" >>$2
      echo "#" >>$2
      echo "#  Inputs: \$1=GUI." >>$2
      echo "#          \$2=MENU_TITLE" >>$2
      echo "#    Uses: VERSION, THIS_FILE, CHOICE, SUMMARY, MENU_TITLE." >>$2
      echo "# Outputs: None." >>$2
      echo "#" >>$2
      echo "f_menu_gui () {" >>$2
      echo "      . $ARRAY_FILE   # invoke the necessary files". >>$2
      echo "      . $THIS_DIR/lib_cli-common.lib" >>$2
      echo "      #" >>$2
      echo "      # CHOICE=\"\"  # Initialize variable." >>$2
      #
      # Get the screen resolution or X-window size.
      # Get rows (height).
      Y=$(stty size | awk '{ print $1 }')
      # Get columns (width).
      X=$(stty size | awk '{ print $2 }')
      #
      echo "      until [ \"\$CHOICE\" = \"QUIT\" ]" >>$2
      echo "            do    # Start of Menu until loop." >>$2
                           MENU_TITLE=$(echo $3 | tr '_' ' ')
      echo "               MENU_TITLE=\"$MENU_TITLE\"" >>$2
      # If screen or window width is greater than MAX_LENGTH_UI (number of characters).
      # Then shrink menu display to fit number of characters.
      if [ $X -gt $4 ] ; then
         X=$4
      fi
      #
      # Pad vertical menu box display for a minimum display area.
      if [ $Y -gt $5 ] ; then
         let Y=$5+9
      fi
      #      
      echo "               CHOICE=\$(\$GUI --clear --title \"\$MENU_TITLE\" --menu \"\n\nUse (up/down arrow keys) or (letters):\" $Y $X $Y \\" >>$2
      TEMP_FILE="cli-app-menu_temp.tmp"
      ARRAY_NAME="CHOICE"
      ARRAY_LEN=$(eval "echo \$\{#$ARRAY_NAME[@]\}")
      ARRAY_LEN=$(eval echo $ARRAY_LEN)
            for (( XNUM=1; XNUM<=${ARRAY_LEN}; XNUM++ ));
                do
                   ARRAY_NAME="CHOICE"
                   CHOICE=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
                   CHOICE=$(eval echo $CHOICE)
                   CHOICE=$(echo $CHOICE | tr '_' ' ')
                   #
                   ARRAY_NAME="SUMMARY"
                   SUMMARY=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
                   SUMMARY=$(eval echo $SUMMARY)
                   SUMMARY=$(echo $SUMMARY | tr '_' ' ')
                   #
                   ARRAY_NAME="FUNC"
                   FUNC=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
                   FUNC=$(eval echo $FUNC)
                   #
                   if [ -n "$CHOICE" ] ; then
                      echo "                     \"$CHOICE\" \"$SUMMARY\" \\" >>$2
                      echo "                    \"$CHOICE\") $FUNC  ;;" >>$TEMP_FILE
                   fi
                done
      echo "               2>&1 >/dev/tty)" >>$2
      echo "               case \$CHOICE in" >>$2
      # Case pattern matching statements are read from TEMP_FILE to be included here.
      cat $TEMP_FILE >>$2
      echo "               esac" >>$2
      echo "            done" >>$2
      echo "       unset MENU_TITLE CHOICE  # Throw out this variable." >>$2
      echo "       #" >>$2
      echo "       } # End of function f_menu_gui." >>$2
      #
      # Remove $TEMP_FILE.
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      unset X Y XNUM TEMP_FILE ARRAY_NAME ARRAY_LEN # CHOICE SUMMARY FUNC 
} # End of function f_update_menu_gui.
#
# +----------------------------------------+
# |          Function f_show_menu          |
# +----------------------------------------+
#
#  Inputs: $1=MENU_TITLE
#          $2=DELIMITER
#          MAINMENU_DIR, THIS_DIR, THIS_FILE, FCOLOR, BCOLOR, UCOLOR.
#    Uses: MOD_FUNC, MOD_FILE, XXSTR.
# Outputs: MAX.
#
f_show_menu () { # $1=$MENU_TITLE $2=$DELIMITER
      MENU_TITLE=$1 ; DELIMITER=$2
      f_term_color $FCOLOR $BCOLOR # Set terminal color.
      #
      clear  # Blank the screen.
      echo -n $(tput bold)
      echo "--- $MENU_TITLE ---"
      echo
      echo "0 - Exit (Go back to the previous menu.)"
      #
      # If displaying "Validate Files and Directories Menu" existing in cliappmenu.sh
      # then this if statement allows for cliappmenu.sh to be in a different
      # directory from all other files.
      # i.e. /home/<username>/cliappmenu.sh
      #      /home/<username>/bin/$THIS_DIR/<All other module library files>.
      case $DELIMITER in
           "#AAD")
           XXSTR=$THIS_DIR         # Save $THIS_DIR. Location of all other files,
                                   # module libraries etc.
           THIS_DIR=$MAINMENU_DIR  # Set $THIS_DIR to location of Main Menu.
          ;;
      esac
      #
      # All menus except Application Category Menu
      # and Software Module Manager Menu display the menu item options in
      # standard colored, bold font.
      #
      # if-statement conditional "($2&&!$3)":
      # Since the $DELIMITER is the special comment marker, then:
      # if there is 1 marker (2 fields) then awk will print the menu item.
      # if there are 2 markers (3 fields), then awk will not print anything.
      # This prevents the lines of code which set the $DELIMITER variable
      # from being printed as a menu item, because they purposely have
      # 2 markers in the same line of code.
      #
      # The same command awk '{<if condition>{print field}}
      # will also print the menu items. The command automatically calculates
      # the menu item option numbers for you by using $XNUM
      # where $XNUM++" -$2" increments the menu item and prints the
      # description of the application.
      #
      echo -n $(tput bold)
      awk -F $DELIMITER '{if ($2&&!$3){print 1+XNUM++" -"$2;}}' $THIS_DIR/$THIS_FILE
      #
      f_choice_array  # Create array to handle numeric answer to menu choices.
                      # Caution: Also uses $XNUM which is used
                      #          in the for-loop within f_choice_array.
      #
      case $DELIMITER in
           # Sub-menus called from Main Menu.
           # Application Sub-category Menus or Application Menus.
           "#M"* | "#B"*)
           echo
           echo "For help, type: '<application name> --help' or 'man <application name>'"
           echo "Also accepts application options i.e. <application name> --version"
           ;;
      esac
      # Calculate $MAX, the number of menu items using grep -c(ount) option.
      # Count number of lines containing special comment marker string to get
      # maximum item number.
      #
      MAX=$(awk -F "$DELIMITER" '{if ($2&&!$3){print $0}}' $THIS_DIR/$THIS_FILE | grep -c "$DELIMITER")
      #
      echo
      echo -n "Enter 0-$MAX or letters (0): " # echo -n suppresses line-feed.
      #
      case $DELIMITER in
           "#AAD")
           THIS_DIR=$XXSTR  # Restore $THIS_DIR. Location of all other files,
                            # module libraries etc.
           ;;
      esac
unset MOD_FUNC MOD_FILE XXSTR   # Throw out this variable.
} # End of function f_show_menu
#
# +----------------------------------------+
# |         Function f_choice_array        |
# +----------------------------------------+
#
#  Inputs: DELIMITER, THIS_DIR, THIS_FILE.
#    Uses: XSTR.
# Outputs: CHOICE[$XNUM], XNUM.
#
f_choice_array () {
      # Create array to handle numeric answer to menu choices.
      # Array Name[index]=Name of menu item (up to 2 words)
      #     CHOICE[$XNUM]=<1st word><space><2nd word>
      #     CHOICE[1]="First choice"
      #     CHOICE[2]="Second choice"
      #
      # The array elements need only the first one or two words of the
      # application name for function f_menu_item_valid to find a match
      # between the numeric answer to the menu choice and the corresponding
      # application name.
      #
      # declare -A CHOICE  # Commented out; do not need to declare the array.
      #
      unset CHOICE  # Throw out this variable.
      XNUM=1 # Initialize XNUM.
      #
      # 1. The 1st awk:
      #    if-statement conditional "($2&&!$3)":
      #    Since the $DELIMITER is the special comment marker, then:
      #    if there is 1 marker (2 fields) then awk will print the 2nd field.
      #    if there are 2 markers (3 fields), then awk will not print anything.
      #    This prevents the lines of code which set the $ DELIMITER variable
      #    from being printed as a menu item, since they have 2 markers.
      #
      # 2. The 2nd awk:
      #    Prints the name of the menu item but not the description.
      #
      # 3. The 3rd awk:
      #    If the name of the menu item is 2 or more words, just print the
      #    first 2 words into array CHOICE[$XNUM] which is sufficient for case
      #    pattern matching on that menu item choice.
      #
      #    Allow app names consisting of 2 words. i.e. "ip addr", "ip route".
      #    The <space> between the words needs a substitution { print $1"%"$2 }
      #    of a "%" for the <space> so awk will not separate the words into 2
      #    different menu items, rather than 1 menu item having 2 words.
      # 
      #    Set XSTR to first two words (delimited by "%" of menu choice name).
      #    Example: Main menu item, "Help and Features"
      #    If not, CHOICE[n]="Help", CHOICE[n+1]="and"
      #    rather than CHOICE[n]="Help and"
      #    (after substituting <space> for "%").
      #                    
      for XSTR in `awk -F $DELIMITER '{ if ( $2&&!$3 ) { print $2 } }' $THIS_DIR/$THIS_FILE | awk -F " - " '{ print $1 }' | awk '{ if ( $2 ) { print $1"%"$2 } else {print $1 } }'`
      # Use back-ticks above before 1st awk and as last character to redirect,
      # do not mistake them for single quotes.
      #
      # When creating CHOICE array, example:
      # The result of the for-loop above using 3 awks may result in XSTR with two words separated by "%" charactor.
      # Restore the space between the two words by substituting "%" with a " " space and save result to the CHOICE array.
      #
      # change XSTR="Help%and" to "Help and".
      #
      # Create CHOICE array to handle numeric answer to menu choices.
      #     CHOICE[$XNUM]=<1st word><space><2nd word>
      #     CHOICE[1]="First choice"
      #     CHOICE[2]="Second choice"
      do
           XSTR=${XSTR/[%]/ }    # Substitute <space> for "%" to restore name.
           CHOICE[$XNUM]=$XSTR   # Create CHOICE array.
           XNUM=`expr $XNUM + 1` # Use expr with back-ticks to increment XNUM.
      # Use back-ticks above before expr and as last character to redirect,
      # do not mistake them for single quotes.
      done
      #
      unset XSTR  # Throw out this variable.
      #
} # End of f_choice_array
#
# +----------------------------------------+
# |      Function f_menu_item_process      |
# +----------------------------------------+
#
#  Inputs: $*, CHOICE[$MENU_ITEM], MAX, SAVE_DIR, THIS_DIR, APP_NAME, MENU_ITEM_OPT.
#          Where "$*" is the complete user-entered string 
#          passed as a set of arguments.
#    Uses: X, DELIM, MENU_ITEM.
# Outputs: PRESS_KEY, XSTR, MENU_ITEM_NAME, DELIMITER, ERROR, SAVE_DIR.
#
f_menu_item_process () {
      #
      # 1. After menu is displayed, process user-entered string
      #    (menu-item selection or any user-input).
      # 2. Did user enter command to exit menu?
      #    Yes, exit menu.
      # 3. Did user enter command for application help?
      #    i.e. <appname> --help or man <appname>.
      #    Yes, display help and then re-display menu.
      # 4. Is user-input a valid choice (menu item option)?
      #    No, trap bad responses and re-display menu.
      # 5. Is field 1 specified?
      #    Yes, run function specified by field 1.
      # 6. Is field 4 specified?
      #    Yes, display message about how to quit application.
      # 7. Is field 3 specified?
      #    Yes, run function specified by field 3.
      # 8. Is the menu an application menu?
      #    Yes, run application, $APP_NAME by running the function
      #    f_application_run.
      # 9. Redisplay menu.
      #
      # The complete user-entered string passed as a set of arguments.
      # i.e. "man <appname>, "<appname> --help" "<web browser><OPTIONS><URL>"
      MENU_ITEM=$*
      PRESS_KEY=0 # Reset flag.
      #
      if [ "$DELIMITER" = "#MZZ" ] ; then
         THIS_DIR=$SAVE_DIR
      fi
      #
      case $MENU_ITEM in
           # Quit?
           "" | 0)
           MENU_ITEM=0
           PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
           ;;
           [1-9] | [1-9][0-9]) # Change MENU_ITEM from a number to
                               # an alpha string.
           if [  "$MENU_ITEM" -ge 1 ] && [ "$MENU_ITEM" -le $MAX ] ; then
              # MENU_ITEM now is an alpha string.
              MENU_ITEM=${CHOICE[$MENU_ITEM]} 
#echo "MENU_ITEM=$MENU_ITEM passed to f_menu_item_process"  # Diagnostic Line.
#echo "Choice Array inside f_menu_item_process." # Diagnostic Line.
#echo "CHOICE Array" # Diagnostic Line.
#echo ${CHOICE[*]}  # Diagnostic Line.
#echo -n "Press Enter key to continue." ; read BOBCHIN  # Diagnostic Line.
           fi
           ;;
      esac
      #
      # All other menus item option "Return" to exit.
      case $MENU_ITEM in
           [Rr] | [Rr][Ee] | [Rr][Ee][Tt] | [Rr][Ee][Tt][Uu]*)
           MENU_ITEM=0
           PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
           ;;
         esac
      #
      # Check if MENU_ITEM includes "--help" or "man "
      # requests for help or man pages.
      f_application_help
      #
      ERROR=0 # Reset error flag.
      #
      # Format of menu item options:
      # "#f_funct1^f_funct2^f_funct3^Quit-Code^PRESS_KEY #MXX Application Name - Description of application."
      #   field-1  field-2  field-3  field-4   field-5   Marker 
      #
      # field 1    *if 1 then function name is f_<MENU_ITEM_NAME>.
      # 1/0/string *if <string> then function name is <string>.
      #            *if 0 then ignored. No function is run.
      #
      #             When this menu item is selected, this function is run
      #             before displaying the Quit-Code on the screen.
      #
      # field 2    *if 1 then function name is f_install_<MENU_ITEM_NAME>.
      # 1/0/string  A function to install an application may be specified here.
      #            *if <string> then function name is <string>.
      #            *if 0 then ignored. No function is run.
      #
      #            This custom installation function is called only after the
      #            distro's software package manager has failed to install the
      #            application usually because the application is not
      #            pre-packaged for the Linux distro (distribution).
      #            See f_application_install for more details.
      #
      #            If install fails, then this custom install function will be
      #            run which can be made to download the source code from the
      #            application maintainer's web site and then compile and
      #            install the application.
      #
      # field 3    *if <string> then function name is <string>.
      # 0/string   *if 0 then ignored. No function is run.
      #
      #             When this menu item is selected, this function is run after
      #             displaying the Quit-Code on the screen.
      #
      # field 4    *Quit-Code. See f_quit_app_clause for more details.
      # string
      #
      # field 5    *Sets PRESS_KEY=0/1 to display:
      #             "Press 'Enter' key to continue".
      # 1/0         See f_press_key for more details.
      #             This allows the user to see any messages displayed by the
      #             application after it has been run.
      #             Without PRESS_KEY=1, the screen is cleared to display the
      #             menu and the user would miss any messages.
      #
      #             This setting may be overridden by any custom functions
      #             which follow.
      #             It is useful if the custom function displays a help message
      #             which sets  PRESS_KEY=1
      #             or has a f_press_enter_key_to_continue or a man page (which
      #             does not need a PRESS_KEY=1). so you don't have to worry
      #             about coding for PRESS_KEY within that custom function.
      #
      #             This can be used to initialize PRESS_KEY as it is set
      #             before any custom functions in fields 1, 2, or 3 are run.
      #             
      if [ "$MENU_ITEM" != 0 ] && [ "$MENU_ITEM" != -1 ] && [ -n "$MENU_ITEM" ] ; then
         # Is MENU_ITEM a valid choice?
         f_menu_item_valid # APP_NAME="" for invalid name.
                           # APP_NAME=$MENU_ITEM_NAME for valid name.
         #
         if [ -n "$APP_NAME" ] ; then # if $MENU_ITEM is a valid choice (null if invalid).
            #
            # If running "Favorite Applications Menu", then invoke the
            # corresponding module file mod_apps-<name>.lib.
            if [ "$DELIMITER" = "#MZZ" ] ; then
               # Extract the application name from user-entered $APP_NAME which
               # may have [OPTIONS] and arguments. i.e. "elinks -lookup jw.org"
               XSTR=$(echo $APP_NAME | awk '{print $1}')
               XSTR=$(grep \#M[A-Z][A-Z]" $XSTR " $THIS_DIR/mod_apps-*.lib | awk '{print $1}' | awk -F ":" '{print $1}')
               XSTR=$(echo $XSTR | awk '{print $1}') 
               . $XSTR # Invoke module "mod_apps-<name>.lib"
            fi
            #
            f_menu_item_info
            #
            # Set PRESS_KEY default before any custom functions
            # since they may also set PRESS_KEY.
            # PRESS_KEY is set depending on the value of field 5.
            f_press_key
            #
            # Specify 1st field of $MENU_ITEM_OPT for function #1.
            f_eval_funct "$MENU_ITEM_OPT" 1
            #
            # Specify 4th field of $MENU_ITEM_OPT for Quit Clause.
            # Do not check for Quit Clause if quitting out of
            # a sub-menu after running an application.
            # APP_NAME is set to null if application is already run.
            if [ -n "$APP_NAME" ] ; then
               f_quit_app_clause
            fi
            #
            # Specify 3rd field of $MENU_ITEM_OPT for function #3.
            f_eval_funct "$MENU_ITEM_OPT" 3
            #
            # Run application program.
            # $APP_NAME="" is set when f_run_and_exit is run prior within
            # function #1, #2, or #3.
            # Don't run "applications" in Main Menu or any of its sub-menus
            # because there are none.
            #
            if [ -n "$APP_NAME" ] ; then
               case $DELIMITER in
               "#AA"*)
               # Menu is not an application menu so do not run applications.
               :  # No-op(eration) command.
               ;;
               *)
               f_application_run
               MENU_ITEM_NAME="" # Null so f_application_run is not run twice
               APP_NAME=""       # when trying to exit sub-menus.
                                 # It's a tricky loop.
                                 # Also prevents checking for Quit Clause.
               ;;
               esac
            fi
#         else    # Diagnostic Line.
#echo "invalid application name."  # Diagnostic Line.
#echo "MENU_ITEM=$MENU_ITEM"  # Diagnostic Line.
#echo "CHOICE Array" # Diagnostic Line.
#echo ${CHOICE[*]}  # Diagnostic Line.
#echo -n "Press Enter key to continue." ; read BOBCHIN  # Diagnostic Line.
         fi
      fi
      #
      # Trap bad menu choices, do not echo Press enter key to continue.
      #
      if [ "$MENU_ITEM" != 0 ] ; then
         MENU_ITEM=-1
      fi
      #
      # Strip off leading "#" of DELIMITER: "#M[A-Z][A-Z]" to "M[A-Z][A-Z]".
      # The "\" treats "#" as a literal hash mark, not as a comment.
      DELIM=${DELIMITER/\#/}   
      # 
      # Set M[A-Z][A-Z] = $MENU_ITEM
      # MENU_ITEM=-1 if application successfully run. Stay in Menu loop.
      #            0 if "Return to previous menu." Exit Menu loop.
      #
      if [ -n "$DELIM" ] ; then  # if DELIM="" then don't eval.
         eval $DELIM=$MENU_ITEM
      fi
      #
      # If application displays information, allow user to read it.
      # Does this override menu item option field #5?
      f_option_press_enter_key
      #
      # At least in the "Configuration Menu" "Update All Modules" it seems to
      # override menu item option field #5 even when it is "0".
      # The menu option item field #1 is "f_update_all_modules"
      # and is processed through this function f_menu_item_process.
      #
      # Note: This does not affect "ALL" option in "Software Module Management
      # Menu" because "f_update_all_modules" is called directly and this
      # function "f_menu_item_process" is bypassed.
      #
      if [ "$DELIMITER" = "#MZZ" ] && [ "$MENU_ITEM" != 0 ] && [ "$MENU_ITEM" != -1 ] ; then
         THIS_DIR=~
      fi
      #
      unset X DELIM MENU_ITEM
      #
} # End of function f_menu_item_process
#
# +----------------------------------------+
# |       Function f_menu_item_valid       |
# +----------------------------------------+
#
#  Inputs: DELIMITER, MAX, THIS_FILE, MENU_ITEM.
#    Uses: XNUM.
# Outputs: MENU_ITEM, MENU_ITEM_NAME, APP_NAME.
#          (If invalid, then APP_NAME is null).
#
f_menu_item_valid () {
      # Get application name from menu.
      XNUM=1
      APP_NAME="" # Set application name to null value.
      #
      # Cycle through entire CHOICE[$XNUM] array
      # to find matching $MENU_ITEM_NAME.
#echo # Diagnostic Line.
#echo "Choice Array inside f_menu_item_valid." # Diagnostic Line.
#echo "CHOICE Array" # Diagnostic Line.
#echo ${CHOICE[*]}  # Diagnostic Line.
#echo -n "Press Enter key to continue." ; read BOBCHIN  # Diagnostic Line.
      while [ $XNUM -ge 1 ] && [ $XNUM -le $MAX ]
      do
            # If no "sudo" or any [OPTIONS] in command then convert MENU_ITEM
            # to lower case.
            # If command contains "sudo" or any [OPTIONS] then don't touch.
            # Assume any sudo-user knows what to type because [OPTIONS] are
            # case-sensitive.
            case $MENU_ITEM in
                 "sudo "*)
                 # If MENU_ITEM contains "sudo", assume any sudo-user knows
                 # whate they are doing and do not convert to lower-case.
                 ;;
                 *" -"*)
                 # if MENU_ITEM contains <dash>, do not convert to lower-case
                 # since -[OPTIONS] may need to be in upper-case.
                 ;;
                 *)
                 # Convert to lower-case.
                 MENU_ITEM=$(echo $MENU_ITEM | tr '[:upper:]' '[:lower:]')
                 ;;
            esac
            #
            # Set (next) MENU_ITEM_NAME from CHOICE array.
            MENU_ITEM_NAME=${CHOICE[$XNUM]}
            # Convert MENU_ITEM_NAME to lower-case.
            # (Sub-menus choice "MORE..." are in upper-case).
            MENU_ITEM_NAME=$(echo $MENU_ITEM_NAME | tr '[:upper:]' '[:lower:]')
            #
            case $MENU_ITEM in
                 [1-9][f] | [1-9][1-9][f] | [1-9][1-9][1-9][f])
                 # User wants to mark the application as a "Favorite" application.
                 # Put the application as a menu item in the "Favorites" menu.
                 # Valid choice so force exit from While-loop.
                 f_favorite_app_add
                 let XNUM=$MAX+1
                 ;;
                 "sudo "$MENU_ITEM_NAME*)
                 # Valid choice, contains $MENU_ITEM_NAME after "sudo".
                 # This pattern matching statement will allow any other sudo formats
                 # i.e. links web browser:
                 #      "sudo links -width 80 -driver atheos -html-images 0".
                 #
                 APP_NAME=$MENU_ITEM
                 # Valid choice so force exit from While-loop.
                 let XNUM=$MAX+1
                 ;;
                 $MENU_ITEM_NAME" "*)
                 # Does MENU_ITEM contain MENU_ITEM_NAME? 
                 # i.e. "nslookup www.distrowatch.com" contains "nslookup "
                 #                                         ("nslookup"<space>).
                 # i.e. "apt-file" does not contain "apt " ( "apt"<SPACE> ).
                 # elif [[ "$MENU_ITEM" == "$MENU_ITEM_NAME "* ]] ; then 
                 # Valid choice, extract APP_NAME.
                 APP_NAME=$MENU_ITEM
                 let XNUM=$MAX+1  # Valid choice so force exit
                                  # from While-loop.
                 ;;
            esac
            #
            case $MENU_ITEM_NAME in
                 $MENU_ITEM*)
                 # Does MENU_ITEM_NAME contain MENU_ITEM?
                 # i.e. "nslookup" contains "nsl"*.
                 MENU_ITEM=$MENU_ITEM_NAME
                 APP_NAME=$MENU_ITEM_NAME
                 let XNUM=$MAX+1  # Valid choice so force exit
                                  # from While-loop.
                 ;;
            esac
            #
            if [ XNUM != $MAX+1 ] ; then
               let XNUM++  # Not valid, try next menu item, force stay in
                           # menu loop.
            fi
      done
      #
      export MENU_ITEM MENU_ITEM_NAME APP_NAME
      unset XNUM
      #
} # End of function f_menu_item_valid
#
# +----------------------------------------+
# |        Function f_menu_item_info       |
# +----------------------------------------+
#
#  Inputs: DELIMITER, MENU_ITEM_NAME, THIS_DIR, THIS_FILE.
#    Uses: XXSTR.
# Outputs: MENU_ITEM_OPT.
#
f_menu_item_info () {
      # Extract MENU_ITEM_OPT string.
      # Awk extracts everything before " #MXX"
      # results in #n^n^n^nn:NC as new string.
      #
      MENU_ITEM_OPT=""
      #
      case $DELIMITER in
           "#AAD")
           # Save $THIS_DIR. Location of all other files, module libraries etc.
           XXSTR=$THIS_DIR
           # Set $THIS_DIR to location of Main Menu.
           THIS_DIR=$MAINMENU_DIR
           ;;
           "#MZZ")
           XXSTR=$THIS_DIR
           THIS_DIR=~
           ;;
      esac
      #
      # grep "$MENU_ITEM_NAME" is in quotes because some menu items
      # have 2 words i.e. "star wars".
      # grep needs -i because my convention is any sub-menus start with an
      # upper-case letter.
      # grep needs "$DELIMITER<SPACE>$MENU_ITEM_NAME because some names are in
      # the descriptions of multiple menu choices i.e. grep -i "morse" would
      # give several hits (results).
      MENU_ITEM_OPT=$(awk -F $DELIMITER '{if ($2&&!$3){print $0}}' $THIS_DIR/$THIS_FILE | grep -i "$DELIMITER $MENU_ITEM_NAME" | awk -F $DELIMITER '{print $1}')
      MENU_ITEM_OPT=$(echo $MENU_ITEM_OPT | awk -F $DELIMITER '{print $1}')
      MENU_ITEM_OPT=${MENU_ITEM_OPT/\#/} # Strip off leading "#".
      # The "\" treats "#" as a literal hash mark, not as a comment.
      #
      # if grep -i finds 2 or more matches,
      # i.e. $MENU_ITEM_NAME="morse" matches both "morse", "morsegen".
      # there will be several strings containing "n^n^n^n^n"
      # i.e. "n^n^n^n^n #n^n^n^n^n"
      # only the first one is valid, use the " #" as a delimiter and take only
      # the first one.
      MENU_ITEM_OPT=$(echo $MENU_ITEM_OPT | awk -F " #" '{print $1}')
      export MENU_ITEM_OPT
      #
      case $DELIMITER in
           "#AAD" | "#MZZ")
           THIS_DIR=$XXSTR  # Restore $THIS_DIR. Location of all other files,
                            # module libraries etc.
           ;;
      esac
      unset XXSTR
} # End of function f_menu_item_info
#
# +----------------------------------------+
# |          Function f_eval_funct         |
# +----------------------------------------+
#
#  Inputs: $1, $2, $MENU_ITEM_NAME
#          $1=$MENU_ITEM_OPT.
#          $2=$Field number.
#    Uses: X, XSTR.
# Outputs: ERROR.
#
f_eval_funct () {
      #
      # Format of menu item options:
      # "#f_funct1^f_funct2^f_funct3^Quit-Code^PRESS_KEY #MXX App Name - Description of application."
      #   field-1  field-2  field-3  field-4   field-5   Marker 
      #
      MENU_ITEM_OPT=$1
      #
      # The 1st awk:
      # Extracts the $2 field from $MENU_ITEM_OPT.
      #
      XSTR=$(echo $MENU_ITEM_OPT | awk -F "^" '{print $X}' X=$2)
      #
      case "$2" in
           1)  # if 1st field is a "1" then <f_app-name>
               # Custom application function for general usage.
           if [ "$XSTR" = 1 ] ; then
              XSTR="f_$MENU_ITEM_NAME"
           fi
           ;;
           2)
           # if 2nd field is a "1" then <f_install_app-name>
           # Custom application installation function.
           if [ "$XSTR" = 1 ] ; then
              # Set $XSTR to the name of the custom installation function.
              XSTR="f_install_$MENU_ITEM_NAME"
           fi
           ;;
           # 3rd field "<f_any_name>"
           # is called after the display of the Quit Code message.
      esac
      #
      # Value of string $XSTR is now:
      # "0"                    if field 1 is "0"
      # "f_<App Name>"         if field 1 is "1".
      # "f_<any function>      if field 1 is <any functionn>
      #
      # "0"                    if field 2 is "0"
      # "f_install_<App Name>" if field 2 is "1".
      # "f_<any function>      if field 2 is <any functionn>
      # 
      # "0"                    if field 3 is "0"
      # "f_<any function>      if field 3 is <any functionn>
      #
      # Do not eval $XSTR if it is "0".
      #
      if [ "$XSTR" != 0 ] && [ -n "$XSTR" ] ; then
         eval $XSTR  # Invoke (run) the function.
      fi
      #
      if [ $? -ne 0 ] ; then
         echo "Failed: $XSTR."
         f_press_enter_key_to_continue
      fi
      #
      # If field 2 is 0 (no custom install function)
      # then set ERROR=1 to force attempt of a web install
      # as per logic in f_application_install.
      #
      if [ $2 = 2 ] && [ "$XSTR" = 0 ] ; then
         ERROR=1
      fi
      #
      unset X XSTR
      #
} # End of function f_eval_funct
#
# +----------------------------------------+
# |       Function f_quit_app_clause       |
# +----------------------------------------+
#
#  Inputs: MENU_ITEM_OPT.
#    Uses: XSTR, QUIT_FIELD, NO_CLEAR.
# Outputs: None.
#
f_quit_app_clause () {
      # 
      # Field 4 is the number of the Quit Code used by f_quit_app_clause.
      # This will display the custom "How to quit" the application message.
      #
      # Format of menu item options: 
      # "#f_funct1^f_funct2^f_funct3^Quit-Code^PRESS_KEY #MXX App Name - Description of application."
      #   field-1  field-2  field-3  field-4   field-5   Marker 
      # 
      # Example 1:
      # String in Quit field of MENU_ITEM_OPT.
      # #0^0^0^13:NC^0
      # "13:NC" or format is "##:NC"
      # This will not clear the screen and display message:
      # To quit "$APP_NAME", type <Ctrl>-Z.
      #
      # Example 2:
      # String in Quit field of MENU_ITEM_OPT.
      # #0^0^0^6^0
      # "6" or format is "##"
      # This will clear the screen and display message:
      # To quit "$APP_NAME", type "(quit)" including the parenthesis.
      #
      #%%1. "Q"
      #%%2. "Q" or "quit"
      #%%3. "Q" or <F10>
      #%%4. ":q" <colon> q (which is the vi command for 'quit')
      #%%5. (lose game and then) type "Q"
      #%%6. "(quit)" including the parenthesis
      #%%7. "quit"
      #%%8. <Ctrl>-C
      #%%9. <Ctrl>-C or <Ctrl>-D or crash into wall
      #%%10. <Ctrl>-D
      #%%11. <Ctrl>-K X
      #%%12. <Ctrl>-X <Ctrl>-C
      #%%13. <Ctrl>-Z
      #%%14. <Esc> :q!
      #%%15. <F5>
      #%%16. at the prompt Command: "terminate"
      #%%17. Alt-Q
      #%%18. "X"
      #%%19. <Ctrl>-Z or <Ctrl>-C
      #%%20. "exit"
      #%%21. "quit" or "exit"
      #%%22. "q or to pause press "p"
      #%%23. "any key"
      #%%24. <Ctrl>-Q
      #%% # End of list marker (and awk field marker), DO NOT remove.
          # This marker prevents awk from printing any more lines found by
          # grep "#%%" below and including this line.
      #
      # Does MENU_ITEM_OPT Quit field contain string?
      # Extract Quit field, 4th field.
      QUIT_FIELD=$(echo $MENU_ITEM_OPT | awk -F "^" '{print $4}')
      # If Quit field is not "0" and has a non-zero length.
      if [ "$QUIT_FIELD" != "0" ] && [ -n "$QUIT_FIELD" ] ; then
         #
         NO_CLEAR=""
         # Convert QUIT_FIELD "nc" to upper-case if there is one.
         QUIT_FIELD=$(echo $QUIT_FIELD | tr '[:lower:]' '[:upper:]')
         #
         if [[ "$QUIT_FIELD" == *":NC"* ]] ; then
            NO_CLEAR="no-clear"  # "no-clear" string exists.
            # Strip ":NC" from QUIT_FIELD.
            QUIT_FIELD=$(echo $QUIT_FIELD | awk -F ":" '{print $1}')
         else
            NO_CLEAR=""  # "no-clear" string is null.
         fi
         #
         # QUIT_FIELD is now the number designation from the list above,
         # corresponding to the keystroke sequence needed to quit the
         # application.
         # i.e. QUIT_FIELD=1 for keystroke sequence "Q"
         #                =2 for "Q or quit"
         #                =3 for "Q or <F10>"...
         #
         QUIT_FIELD=`expr $QUIT_FIELD + 1`
         # Use back-ticks with expr to increment QUIT_FIELD by 1 to get field
         # number for awk (since field #1 is null).
         #
         XSTR=$(grep "#%%" $THIS_DIR/lib_cli-common.lib)
         # Get list of Quit Fields in a single big string.
         # Match integer of QUIT_FIELD to grepped XSTR containing that value.
         #
         # Extract keystroke sequence from matching grepped string and set
         # QUIT_FIELD to that string.
         # 1st awk gets "NN. <Keystroke sequence>" i.e "13. <Ctrl>-Z".
         # 2nd awk strips away numbers "NN." leaving " <Keystroke sequence>"
         #         i.e. "<Ctrl>-Z".
         #         To pass QUIT_FIELD into awk so that field is printed by awk,
         #         insert "QUIT_FIELD=$QUIT_FIELD" after '{print $QUIT_FIELD}'.
         QUIT_FIELD=$(echo $XSTR | awk -F "#%%" '{print $QUIT_FIELD}' QUIT_FIELD=$QUIT_FIELD | awk -F "." '{print $2}')
         #
         # Remove any <spaces> at the end of the string QUIT_FIELD.
         QUIT_FIELD=$(echo $QUIT_FIELD | sed 's/ *$//')
         #
         f_how_to_quit_application "$QUIT_FIELD" $NO_CLEAR
      fi
      #
      unset XSTR QUIT_FIELD NO_CLEAR
      #
} # End of function f_quit_app_clause
#
# +----------------------------------------+
# |          Function f_press_key          |
# +----------------------------------------+
#
#  Inputs: MENU_ITEM_OPT.
#    Uses: X, XSTR.
# Outputs: PRESS_KEY.
#
f_press_key () {
      #
      # Field 5 sets PRESS_KEY=1/0. May be over-ridden by subsequent functions
      # which also set PRESS_KEY.
      #
      # Format of menu item options:
      # "#f_funct1^f_funct2^f_funct3^Quit-Code^PRESS_KEY #MXX App Name - Description of application."
      #   field-1  field-2  field-3  field-4   field-5   Marker
      #
      XSTR=$(echo $MENU_ITEM_OPT | awk -F "^" '{print $5}')
      if [ "$XSTR" != 0 ] && [ -n "$XSTR" ] ; then
         PRESS_KEY=1 # Display "Press 'Enter' key to continue."
      else
         PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
      fi
      export PRESS_KEY
      unset X XSTR
      #
} # End of function f_press_key
#
# +----------------------------------------+
# |         Function f_run_and_exit        |
# +----------------------------------------+
#
#  Inputs: $1 $2. 
#          $1=application name
#          $2=$APP_NAME 
#    Uses: X.
# Outputs: APP_NAME, PRESS_KEY.
#
f_run_and_exit () {
      echo "To quit $1, type <Ctrl>-Z or <Ctrl>-C."
      echo "(There is no way to cleanly return to the menu)."
      echo "Running $1 will exit this menu script."
      echo
      echo -n "Run $1 and exit script? (y/N): "
      read X
      case $X in
           [Yy] | [Yy][Ee] | [Yy][Ee][Ss])
           APP_NAME=$2
           f_application_run
           APP_NAME=""
           ;;
           [Nn] | [Nn][Oo] | *)
           APP_NAME=""
           PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
           ;;
      esac
      unset X
      #
} # End of function f_run_and_exit
#
# +----------------------------------------+
# |   Function f_how_to_quit_application   |
# +----------------------------------------+
#
#  Inputs: $1, $2, APP_NAME.
#          $1 typed key to quit. 
#          $2 string "no-clear" if screen should not be cleared.
#    Uses: None.
# Outputs: None.
#
f_how_to_quit_application () { 
      #
      if [ -z $2 ] ; then
         clear # Blank the screen.
      fi
      # If $APP_NAME in a web browser application then format may be too long
      # for a 80-character display.
      # Format OF $APP_NAME could be:
      # "<APP_NAME>", <APP_NAME> <Web site>"
      # "sudo <APP_NAME> <OPTIONS> <Web site>".
      #
      # If $APP_NAME includes a web application, shorten the message.
      case $APP_NAME in
           *elinks* | *fbcmd* | *links* | *links2* | *lynx* | *pastebinit* | *retawq* | *surfraw* | *w3m*)
           echo
           echo "To quit the web browser, type $1."
           f_press_enter_key_to_continue
           ;;
           *)
           echo
           echo "To quit \"$APP_NAME\", type $1."
           f_press_enter_key_to_continue
           ;;
      esac
      #
} # End of function how_to_quit_application
#
# +----------------------------------------+
# |          Function f_term_color         |
# +----------------------------------------+
#
#  Inputs: $1=$FCOLOR. $2=$BCOLOR
#    Uses: CNT, TPUTX.
# Outputs: None.
#
f_term_color () {  # Set terminal display properties.
      #
      # BASH commands to change the color of characters in a terminal.
      # bold    "$(tput bold)"
      # black   "$(tput setaf 0)"
      # red     "$(tput setaf 1)"
      # green   "$(tput setaf 2)"
      # yellow  "$(tput setaf 3)"
      # blue    "$(tput setaf 4)"
      # magenta "$(tput setaf 5)"
      # cyan    "$(tput setaf 6)"
      # white   "$(tput setaf 7)"
      # reset   "$(tput sgr0)"
      #
      # setterm does not work in X-window virtual terminals.
      # setterm -foreground white -background black -bold on -store
      #
      # set background first because you must reset colors first to get true
      # black background in some virtual X-terminals. Since "tput setab 0"
      # appears light gray, use "tput sgr0" to reset colors.
      #
      # set CNT=1 background color then set CNT=2 font color.
      for CNT in 1 2
      do
          if [ $CNT -eq 1 ] ; then
             
             TPUTX="setab"  # Background color.
             COLOR=$2
          else
             TPUTX="setaf"  #  Font color (Fore-ground color).
             COLOR=$1
          fi
          case $COLOR in
               [Bb] | [Bb][Ll] | [Bb][Ll][Aa]*)
               if [ $CNT -eq 1 ] ; then
                  echo -n $(tput sgr0)  # Black background selected.
                                        # Reset colors to get true black.
               else
                  echo -n $(tput $TPUTX 0)  # Black font selected.
               fi
               ;;
               [Bb] | [Bb][Ll] | [Bb][Ll][Uu]*)
               echo -n $(tput $TPUTX 4)  # Blue font/background selected.
               ;;
               [Cc] | [Cc][Yy]*)
               echo -n $(tput $TPUTX 6)  # Cyan font/background selected.
               ;;
               [Gg] | [Gg][Rr] | [Gg][Rr][Ee]*)
               echo -n $(tput $TPUTX 2)  # Green font/background selected.
               ;;
               [Gg] | [Gg][Rr] | [Gg][Rr][Aa]*)
               echo -n $(tput $TPUTX 237)  # Gray font/background selected.
               ;;
               [Mm] | [Mm][Aa]*)
               echo -n $(tput $TPUTX 5)  # Magenta font/background selected.
               ;;
               [Rr] | [Rr][Ee] | [Rr][Ee][Dd])
               echo -n $(tput $TPUTX 1)  # Red font/background selected.
               ;;
               [Rr] | [Rr][Ee] | [Rr][Ee][Ss]*)
               echo -n $(tput sgr0)  # Reset selected.
               ;;
               [Ww] | [Ww][Hh]*)
               echo -n $(tput $TPUTX 7)  # White font/background selected.
               ;;
               [Yy] | [Yy][Ee]*)
               echo -n $(tput $TPUTX 3)  # Yellow font/background selected.
               ;;
          esac
      done
      #
} # End of function f_term_color
#
# +----------------------------------------+
# | Function f_press_enter_key_to_continue |
# +----------------------------------------+
#
#  Inputs: None.
#    Uses: X.
# Outputs: None.
#
f_press_enter_key_to_continue () { # Display message and wait for user input.
      . lib_cli-common.lib # Invoke the common library.
      echo
      echo -n "Press \"Enter\" key to continue."
      read X
      unset X  # Throw out this variable.
      #
} # End of function f_press_enter_key_to_continue
#
# +----------------------------------------+
# |   Function f_option_press_enter_key    |
# +----------------------------------------+
#
#  Inputs: PRESS_KEY.
#    Uses: None.
# Outputs: None.
#
f_option_press_enter_key () { # Display message and wait for user input.
      # $PRESS_KEY = 0 means Do not display "Press 'Enter' key to continue."
      # $PRESS_KEY = 1 means Display "Press 'Enter' key to continue."
      #
      if [ "$PRESS_KEY" -eq 1 ] ; then
         f_press_enter_key_to_continue
      fi
} # End of function f_option_press_enter_key
#
# +----------------------------------------+
# |       Function f_application_help      |
# +----------------------------------------+
#
#  Inputs: MENU_ITEM, ERROR, FCOLOR, BCOLOR, ECOLOR.
#          MENU_ITEM="<Application name> --help"
#          MENU_ITEM="man <Application name>"
#    Uses: None.
# Outputs: APP_NAME, ERROR, PRESS_KEY, MENU_ITEM=-1.
#
f_application_help () {
      case $MENU_ITEM in
           *--version)
           PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                       # Default assumes that version messages exist.
           clear # Blank screen
           # awk extracts only the application's name to use for APP_NAME.
           APP_NAME=$(echo $MENU_ITEM | awk '{print $1;}')
           #
           # Test to see if the application is installed. 
           # This returns path of application's run-time executable command.
           # Do not display any messages on screen.
           # Redirect error and standard output to null device.
           command -v $APP_NAME &>/dev/null
           # 1=standard messages, 2=error messages, &=both.
           ERROR=$? # Save error flag condition.
           # Error code 1 $?=1 means application is not installed.
           # Error code 0 (zero) where $?=0 means no error.
           #
           # Application is installed.
           if [ $ERROR -eq 0 ] ; then
              # Display --version message.
              $MENU_ITEM  # Run <Application name> --version
           fi
           #
           # Application is not installed.
           if [ $ERROR -ne 0 ] ; then
              # Error code 1 $?=1 means no --version option available.
              # Error code 0 (zero) where $?=0 means no error.
              #
              # Use different color font for error messages.
              f_term_color $ECOLOR $BCOLOR
              echo $(tput bold)
              #
              echo "No '--version' option is available for $APP_NAME."
              f_application_help_mssg
           fi
           MENU_ITEM=-1 # Force stay in menu until loop.
                        # Convert string to integer -1.
                        # Also indicates valid menu choice.
                        # If valid, f_bad_application_menu_choice will not
                        # force PRESS_KEY=1.
           APP_NAME=""  # Make sure that application is not run after
                        # displaying message.
                        # Make sure that f_application_run is not run.
           ;;
           *--help)
           PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                       # Default assumes that help messages exist.
           clear # Blank screen
           # awk extracts only the application's name to use for APP_NAME.
           APP_NAME=$(echo $MENU_ITEM | awk '{print $1;}')
           #
           # Test to see if the application is installed. 
           # This returns path of application's run-time executable command.
           # Do not display any messages on screen.
           # Redirect error and standard output to null device.
           command -v $APP_NAME &>/dev/null
           # 1=standard messages, 2=error messages, &=both.
           ERROR=$? # Save error flag condition.
           # Error code 1 $?=1 means application is not installed.
           # Error code 0 (zero) where $?=0 means no error.
           #
           # Application is installed.
           if [ $ERROR -eq 0 ] ; then
              # Display help message.
              $MENU_ITEM  # Run <Application name> --help
           fi
           #
           # Application is not installed so no --help exists.
           if [ $ERROR -ne 0 ] ; then
              # Use different color font for error messages.
              f_term_color $ECOLOR $BCOLOR
              echo $(tput bold)
              #
              echo "No '--help' option is available for $APP_NAME."
              f_application_help_mssg
           fi
           MENU_ITEM=-1 # Force stay in menu until loop.
                        # Convert string to integer -1.
                        # Also indicates valid menu choice.
                        # If valid, f_bad_application_menu_choice will not
                        # force PRESS_KEY=1.
           APP_NAME=""  # Make sure that application is not run after
                        # displaying message.
                        # Make sure that f_application_run is not run.
           ;;
           man' '*)
           PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
                       # Default assumes that man pages exist.
           clear # Blank screen
           # awk extracts only the application's name to use for APP_NAME.
           APP_NAME=$(echo $MENU_ITEM | awk '{print $2;}')
           #
           # Test to see if the application is installed. 
           # This returns path of application's run-time executable command.
           # Do not display any messages on screen.
           # Redirect error and standard output to null device.
           command -v $APP_NAME &>/dev/null
           # 1=standard messages, 2=error messages, &=both.
           ERROR=$? # Save error flag condition.
           # Error code 1 $?=1 means application not installed.
           # Error code 0 (zero) where $?=0 means no error.
           #
           # Application is installed.
           if [ $ERROR -eq 0 ] ; then
              # Display help message.
              $MENU_ITEM  # Run man <Application name>
              ERROR=$? # Save error flag condition.
              # Error code 1 $?=1 means no man pages available.
              # Error code 0 (zero) where $?=0 means no error.
              #
              # Application is installed but no man pages exist.
              # Display any messages that no man pages exist.
              if [ $ERROR -ne 0 ] ; then
                 PRESS_KEY=1 # Display "Press 'Enter' key to continue."
              fi
           fi
           #
           # Application is not installed so no man pages exist.
           if [ $ERROR -ne 0 ] ; then
              # Error code 16 where $?=16 means no man(ual) entry available.
              # Error code 0 (zero) where $?=0 means no error.
              #
              # Display any messages that no man pages exist.
              PRESS_KEY=1 # Display "Press 'Enter' key to continue."
              #
              # Use different color font for error messages.
              f_term_color $ECOLOR $BCOLOR
              echo $(tput bold)
              #
              echo "No manual pages are available for $APP_NAME."
              f_application_help_mssg
           fi
           MENU_ITEM=-1 # Force stay in menu until loop.
                        # Convert string to integer -1.
                        # Also indicates valid menu choice.
                        # If valid, f_bad_application_menu_choice will not
                        # force PRESS_KEY=1.
           APP_NAME=""  # Make sure that application is not run after
                        # displaying message.
                        # Make sure that f_application_run is not run.
           ;;
      esac
#
} # End of function f_application_help
#
# +----------------------------------------+
# |   Function f_application_help_mssg     |
# +----------------------------------------+
#
#  Inputs: APP_NAME, FCOLOR, BCOLOR.
#    Uses: None.
# Outputs: None.
#
f_application_help_mssg () {
      echo
      echo "This $APP_NAME application is either not installed"
      echo "or is installed but --version, --help or man pages were never written for it."
      echo
      echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR
      #
      # Note the $APP_NAME is not necessarily the package name
      # i.e. "trek" is in the "bsdgames" package.
      #
      echo "To install under Debian-based Linux use command:"
      echo "                           sudo apt-get install <application package name>"
      echo
      echo "To install under Red Hat-based Linux use command:"
      echo "                           sudo rpm -ivh <application package name>"
      echo
      echo "To install under Arch-based Linux use command:"
      echo "                           sudo pacman -S <application package name>"
      echo
      echo "To install under Slackware-based Linux use command:"
      echo "                           sudo installpkg <application package name>"
      echo "                           sudo slackpkg <application package name>"
      echo $(tput bold)
      #
} # End of function f_application_help_mssg
#
# +----------------------------------------+
# |       Function f_application_run       |
# +----------------------------------------+
#
#  Inputs: APP_NAME.
#    Uses: None.
# Outputs: ERROR, MENU_ITEM=-1.
#
f_application_run () {
      #
      # 1. Clear screen.
      # 2. Run application.
      # 3. Error?
      #    No, DONE AND EXIT.
      # 4. Error codes 1, 13, 62?
      #    Yes, then call f_application_error to display error message.
      #    Error codes 1, 13, 62?
      #    Yes, DONE AND EXIT.
      # 5. Error code 127?  Application not installed?
      #    No, DONE AND EXIT.
      #    Yes, then call f_application_error to display error message.
      # 6. Does user want to install missing application?
      #    No, DONE AND EXIT.
      # 7. Yes, f_application_install_question calls f_application_install.
      # 8. Was installation successful?
      #    No, DONE AND EXIT.
      # 9  Yes, run application.
      # 10. Call f_application_error to display any error messages.
      # 11. DONE AND EXIT.
      #
      MENU_ITEM=-1 # Force stay in menu until loop.
      # Convert string to integer -1. Also indicates valid menu choice.
      # If valid, f_bad_application_menu_choice will not force PRESS_KEY=1.
      #
      clear # Blank the screen.
      #
      $APP_NAME # Run application.
      #
      ERROR=$? # Save error flag condition.
      case $ERROR in
           0)  #No error, successful run.
           ;;
           127)  # Error code 127 means application is not installed.
           f_application_error # Display error messages.
           # If user decided to install application.
           f_application_install_question
           # Install application if INSTALL_ANS="YES".
           #
           # Test to see if the application was installed successfully.
           # This returns path of application's run-time executable command.
           # Do not display any messages on screen.
           # Redirect error and standard output to null device.
           #
           command -v $APP_NAME &>/dev/null
           # 1=standard messages, 2=error messages, &=both.
           ERROR=$? # Save error flag condition.
           # Error code 1 $?=1 means application not installed.
           # Error code 0 (zero) where $?=0 means no error.
           #
           # Is the application is installed?
           # If install is successful, then run application.
           if [ "$ERROR" = "0" ] ; then
              $APP_NAME           # Run application.
              ERROR=$? # Save error flag condition.
              f_application_error # Display any error messages.
           fi
           ;;
           1 | 13 | 62 )  # Various errors.
           f_application_error # Display appropriate error message.
           ;;
           *)  # If any error [!0] occurs (error code is not zero).
           f_application_error # Display appropriate error message.
           ;;
      esac
      #
} # End of function f_application_run
#
# +----------------------------------------+
# |          Function f_run_app            |
# +----------------------------------------+
#
#  Inputs: $1=Search string, THIS_DIR, FCOLOR BCOLOR, ECOLOR.
#    Uses: APP_NAME, MENU_ITEM_OPT, MOD_FILE.
# Outputs: ERROR.
#
# Search LIST_APPS file for application names and display the list to allow
# user to run an application.
#
f_run_app () {
      APP_NAME="-1"
      while [ -n "$APP_NAME" ]
      do
            clear # Blank the screen.
            echo "Search results of \"$1\"".
            echo
            # Search LIST_APPS - The application names are at the
            # beginning of each line and are preceded by a <space>.
            # To find these names, the basic command is:
            # grep ^" "$XSTR
            #
            # Display actual search results on screen.
            grep --color=always ^" "$1 $THIS_DIR"/LIST_APPS"
            ERROR=$? # Save error flag condition.
            # Error code 2 means grep had an error.
            # Error code 1 means grep did not find any matches.
            # Error code 0 (zero) where $?=0 means grep found matches.
            #
            if [ $ERROR -ne 0 ] ; then
               # No results found, quit out of f_run_app.
               APP_NAME="" # to quit out of while-loop of f_run_app.
               # Use different color font for error messages.
               f_term_color $ECOLOR $BCOLOR
               echo -n $(tput bold)
               echo
               echo "No applications beginning with \"$1\" were found."
               f_term_color $FCOLOR $BCOLOR
               echo $(tput bold)
               f_press_enter_key_to_continue
            else
               f_ask_run_app $1
            fi
      done
                  unset APP_NAME MENU_ITEM_OPT MOD_FILE
} # End of function f_run_app
#
# +----------------------------------------+
# |         Function f_ask_run_app         |
# +----------------------------------------+
#
#  Inputs: $1=Name of application found previously, THIS_DIR.
#    Uses: None.
# Outputs: APP_NAME, ERROR.
#
f_ask_run_app () {
      echo
      echo "If you want to run the application now, type the FULL NAME at the prompt."
      echo "without any following options or parameters."
      echo
      echo "To quit, press 'Enter' key."
      echo
      #
      echo -n "Name of application to run: "
      read APP_NAME
      #
      # Find any matches for APP_NAME to see if it is a valid application name.
      #
      # grep -w OPTION will find only matches where $APP_NAME is a
      # whole word match and not a partial word match.
      # i.e. "hto" is not a match to an application name.
      #      "htop" is a match to an application name.
      # Note: The regular application menus do accept partial word matches.
      #
      # Redirect error and standard output to null device.
      #          1=standard messages, 2=error messages, &=both.
      grep -w --color=always \#[A-Z][A-Z][A-Z]" "$APP_NAME" " $THIS_DIR/* &>/dev/null
      #
      ERROR=$? # Save error flag condition.
      # Error code 2 means grep had an error.
      # Error code 1 means grep did not find any matches.
      # Error code 0 (zero) where $?=0 means grep found matches.
      #
      if [ $ERROR -eq 0 ] && [ -n "$APP_NAME" ] ; then
         #
         # case statement replaces if ! [[ "$APP_NAME" == "$1"* ]] ; then
         #
         case $APP_NAME in
              $1*)
              # $APP_NAME matches the name of an application
              # found in the previous search results.
              f_run_app_good
              ;;
              *)
              # $APP_NAME is a valid application name but does not match the
              # name of an application found in the previous search results.
              f_run_app_bad
              ;;
         esac
      else
         # Cannot run APP_NAME because:
         # 1. grep found no matches for $APP_NAME in any mod_apps-* files.
         # 2. APP_NAME=""
         f_run_app_bad
      fi
} # End of function f_ask_run_app
#
# +----------------------------------------+
# |         Function f_run_app_bad         |
# +----------------------------------------+
#
#  Inputs: APP_NAME, ERROR, FCOLOR, BCOLOR, ECOLOR.
#    Uses: None.
# Outputs: APP_NAME.
#
f_run_app_bad () {
      # If APP_NAME="" then user wants to exit out.
      if [ -z "$APP_NAME" ] ; then
         APP_NAME="" # to quit out of while-loop of f_run_app
         # without any messages displayed to user.
         #
      fi
      #
      if [ $ERROR -ne 0 ] && [ -n "$APP_NAME" ] ; then
         # No results found, quit out of f_run_app.
         # Use different color font for error messages.
         f_term_color $ECOLOR $BCOLOR
         echo -n $(tput bold)
         echo
         echo "No application \"$APP_NAME\" was found."
         f_term_color $FCOLOR $BCOLOR
         echo $(tput bold)
         f_press_enter_key_to_continue
         APP_NAME=""
         # to quit out of while-loop of f_run_app.
      fi
      #
      # If search results do not match the beginning of APP_NAME.
      # Force user to run only an application found in the previous search.
      # i.e. User searched for application "htop"
      # but entered the name "atop" at the run prompt.
      #
      if [ $ERROR -eq 0 ] && [ -n "$APP_NAME" ] ; then
         # $APP_NAME is a valid application name but does not match the
         # name of an application found in the previous search results.
         # Use different color font for error messages.
         f_term_color $ECOLOR $BCOLOR
         echo -n $(tput bold)
         echo
         echo "Application \"$APP_NAME\" does not match previous search results."
         f_term_color $FCOLOR $BCOLOR
         echo $(tput bold)
         f_press_enter_key_to_continue
         APP_NAME="" # to quit out of while-loop of f_run_app.
      fi

} # End of function f_ask_run_app_bad
#
# +----------------------------------------+
# |         Function f_run_app_good        |
# +----------------------------------------+
#
#  Inputs: APP_NAME, ERROR, THIS_DIR, FCOLOR, BCOLOR, ECOLOR.
#    Uses: None.
# Outputs: MENU_ITEM, MENU_ITEM_NAME, MENU_ITEM_OPT, MOD_FILE.
#
f_run_app_good () {
      # 1. Search all files mod_apps-* listing which ones contain the
      #    application name.
      # 2. Invoke the file mod_apps-* (also called a module).
      # 3. Extract the MENU_ITEM_OPT string from the file mod_apps-*.
      # 4. Run the application with f_application_run.
      #
      # 1. Search for function declaration
      #    "f_<application name> () {" in all files.
      #    Example: if application name is "elinks"
      #    search for "f_elinks () {" in all files.
      #
      MOD_FILE=$(grep -w \#[A-Z][A-Z][A-Z]" "$APP_NAME" " $THIS_DIR/* | awk -F ":" '{print $1}')
      #
      # If If an f_<application name> is found in 2 or more mod_apps-* files,
      # then $MOD_FILE will have a <CR><LF> (New Line) between the mod_apps-*
      # file names.
      #
      # Extract only the first mod_app-* file name when there is more than one.
      # Use a temporary file for the awk input file.
      # A piped input did not work for unknown reasons.
      # i.e. echo $MOD_FILE | awk '{print $1}'
      # so a temporary file had to be used instead.
      echo $MOD_FILE > ~/.cliappmenu.tmp
      MOD_FILE=$(awk '{print $1}' ~/.cliappmenu.tmp)
      rm ~/.cliappmenu.tmp
      #
      # MOD_FILE now includes full directory path
      # "$THIS_DIR/<Module file name>".
      #
      # 2. Invoke the module library, file mod_apps-*
      if [ -r $MOD_FILE ] ; then
         . $MOD_FILE  # Invoke module library.
      fi
      #
      # 3. Extract MENU_ITEM_OPT string.
      # grep finds lines in all mod_apps-* files with
      # <special menu item marker> <space> <APP_NAME>.
      #      #1^1^0^0^1  #MXX trekx     - Trek 73 (1973) ported from Turbo PASCAL to C by Howard Chu.
      #
      # Then awk extracts everything before " #MXX"
      # results in #n^n^n^nn:NC as new string.
      #      #1^1^0^0^1
      #
      # Finally, sed strips off any trailing spaces.
      #
      MENU_ITEM_OPT=$(grep -w \#[A-Z][A-Z][A-Z]" "$APP_NAME $MOD_FILE | awk -F "#" '{print $2}' | sed 's/ *$//')
      #
      # MENU_ITEM, MENU_ITEM_NAME is needed for
      # f_eval_funct.
      MENU_ITEM_NAME=$APP_NAME
      MENU_ITEM=$APP_NAME
      #
      # Specify 1st field of $MENU_ITEM_OPT for function #1.
      f_eval_funct "$MENU_ITEM_OPT" 1
      #
      # Specify 4th field of $MENU_ITEM_OPT for Quit Clause.
      f_quit_app_clause
      #
      # Specify 3rd field of $MENU_ITEM_OPT for function #3.
      f_eval_funct "$MENU_ITEM_OPT" 3
      #
      # 4. Run application program.
      #
      f_application_run
      f_press_enter_key_to_continue
} # End of function f_ask_run_app_good
#
# +----------------------------------------+
# |       Function f_favorite_app_add      |
# +----------------------------------------+
#
#  Inputs: DELIMITER, THIS_FILE, , THIS_DIR, MENU_ITEM.
#    Uses: None.
# Outputs: File: "cli-app-menu-favorites.txt" in home directory.
#          XNUM, XXSTR, XSTR, YSTR, MENU_ITEM_NAME, CHOICE[$XNUM].
#
f_favorite_app_add () {
       XNUM=$(echo $MENU_ITEM | awk -F "f" '{print $1}')
       # Set (next) MENU_ITEM_NAME from CHOICE array.
       MENU_ITEM_NAME=${CHOICE[$XNUM]}
       # Convert MENU_ITEM_NAME to lower-case.
       # (Sub-menus choice "MORE..." are in upper-case).
       MENU_ITEM_NAME=$(echo $MENU_ITEM_NAME | tr '[:upper:]' '[:lower:]')
       #
       XXSTR=$(awk -F $DELIMITER '{if ($2&&!$3){print $0}}' $THIS_DIR/$THIS_FILE | grep -i "$DELIMITER $MENU_ITEM_NAME" | awk -F $DELIMITER '{print $0}')
       #
       # $XSTR contains the MENU_OPTIONS.
       XSTR=$(echo $XXSTR | awk -F "#M" '{print $1}')
       #
       # $YSTR contains application's name and description.
       # {$1=$2="";print $0} Print all fields except the first 2 fields.
       # i.e. Will not print "#0^0^0^0^0 #MAA". But print name and description.
       YSTR=$(echo $XXSTR | awk '{$1=$2="";print $0}')
       # Delimiter for Favorites Menu is "#MZZ".
       XXSTR=$(echo $XSTR" #MZZ "$YSTR)
       echo $XXSTR >> ~/cli-app-menu-favorites.txt
} # End of function f_favorite_app_add
#
# +----------------------------------------+
# |       Function f_application_error     |
# +----------------------------------------+
#
#  Inputs: ERROR, APP_NAME, FCOLOR, BCOLOR, ECOLOR.
#    Uses: ANS, APP_NAME_TMP.
# Outputs: MENU_ITEM, PRESS_KEY, APP_NAME_SUDO.
#          
f_application_error () {
      if [ $ERROR -ne 0 ] ; then
         case $APP_NAME in # Start of APP_NAME case statement.
              sudo' '*)
              # Strip 'sudo', options and parameters from APP_NAME
              # by using awk command.
              APP_NAME_TMP=$(echo $APP_NAME | awk '{print $2;}')
              ;;
              *)
              # If string APP_NAME includes spaces for
              # run-time parameters, then just extract package name.
              # i.e. "dstat 1 10", then extract "dstat" as package name.
              # i.e. "dstat --version", then extract "dstat" as package name.
              APP_NAME_TMP=$(echo $APP_NAME | awk '{print $1;}')
              ;;
         esac # End of APP_NAME case statement.
         #
         # Be sure variable is set to redisplay current menu afterwards.
         MENU_ITEM=-1   # Initialize to -1 to force until loop 
                        # without exiting Sub-Category Menu.
         PRESS_KEY=1    # Display "Press 'Enter' key to continue."
                        # for all errors.
      fi
      #
      case $ERROR in # Start of Error Number case statement.
           1) # Error code 1 is a general error code. But it does not always
              # mean there actually was an error.
              # Some applications exit with error code 1
              # even if successfully run.
              # The Error Code 1 Number Exceptions case statement, takes care
              # of those weird applications.
              #
           # Start of Error Code Number 1 Exceptions case statement.
           case $APP_NAME in
                *diff*)
                # Do not display error message if error code 1
                # and apps colordiff, diff, imediff2, vimdiff, wdiff.
                # For diff apps, error code 1 means compared files are
                # different, not a real error.
                ;;
                xorcurses)
                # Do not display error message if error code 1
                # Application always exits with error code 1 for some
                # bizarre reason.
                ;;             
                sudo' '*)
                # Display error message.
                f_display_error_code
                echo
                echo "Try running \"$APP_NAME_TMP\" without the sudo command."
                echo "There is a possibility that the application is not installed."
                ;;
                *)
                # Display error message.
                f_display_error_code
                echo "Run \"$APP_NAME\" again this time using sudo?"
                echo -n "Use sudo (temporary root permissions)? (y/N): "
                read ANS
                case $ANS in  # Start of Use SUDO case statement.
                     [Yy] | [Yy][Ee] | [Yy][Ee][Ss])
                     APP_NAME_SUDO=$APP_NAME # Don't modify APP_NAME
                     sudo $APP_NAME_SUDO
                     ERROR=$? # Save error flag condition.
                     # Error code 1 $?=1 means sudo failed.
                     # Error code 0 (zero) where $?=0 means no error.
                     #
                     if [ $ERROR -ne 0 ] ; then
                        # Error after running with sudo?
                        # Display error message.
                        f_display_error_code
                        #
                        # Use different color font for error messages.
                        f_term_color $ECOLOR $BCOLOR
                        echo $(tput bold)
                        #
                        echo "Running \"sudo $APP_NAME_SUDO\" failed."
                        #
                        echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
                        echo "May be caused by bad sudo password, or user has no permission to use sudo,"
                        echo "or bad $APP_NAME_TMP syntax."
                        echo "Consult help using man $APP_NAME_TMP."
                        echo
                     fi
                     ;;
                     [Nn] | [Nn][Oo] | *)
                     ERROR=0
                     ;;
                esac # End of Use SUDO case statement.
                ;;
           esac # End of Error Code Number 1 Exceptions case statement.
           ;;
           2) # Error code 2 means operand or files is missing.
           # Display error message.
           f_display_error_code
           #
           # Use different color font for error messages.
           f_term_color $ECOLOR $BCOLOR
           echo $(tput bold)
           #
           echo "Missing operand (file name(s) or names)."
           echo "Try running \"$APP_NAME_TMP\" again this time using operands."
           #
           echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
           echo
           echo "Operands may be filenames as in the examples below."
           echo "Example: $APP_NAME_TMP <filename> or $APP_NAME_TMP <filename1> <filename2>"
           echo "Example: locate test1.txt     or diff test1.txt test2.txt"
           echo
           echo "Or operands may be a combination of parameters, options, and filenames."
           echo "Example: $APP_NAME_TMP <parameters> <filename> <options>"
           echo "Example: find /home -iname test1.txt -print"
           ;;
           100) # Error code 100 means installation application
                # "apt-get" is locked by another process.
           # Display error message.
           f_display_error_code
           #
           # Use different color font for error messages.
           f_term_color $ECOLOR $BCOLOR
           echo $(tput bold)
           #
           echo "This \"$APP_NAME_TMP\" application may be locked and in use by another process."
           #
           echo
           echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
           ;;
           126) # Error code 126 means bad interpreter.
                # Programming language is not installed?
                # Example: perl programming language cannot be found,
                # or environment not specified in the perl script.
           #
           # Display error message.
           f_display_error_code
           # Use different color font for error messages.
           f_term_color $ECOLOR $BCOLOR
           echo $(tput bold)
           #
           echo "The programming environment may not be specified correctly in the first line"
           echo "of the application."
           echo
           echo "Example: An application which is a perl script may not have the first line correct."
           echo "         Change from: #!/usr/local/bin/perl"
           echo "         Change   to: #!/usr/bin/env perl"
           echo
           echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
           ;;
           127) # Error code 127 means application is not installed.
           # Display error message.
           f_display_error_code
           #
           # Use different color font for error messages.
           f_term_color $ECOLOR $BCOLOR
           echo $(tput bold)
           #
           echo "This \"$APP_NAME_TMP\" application"
           echo "cannot be run since it is not yet installed."
           echo
           echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
           ;;
           13 | 62 | [!0]) # All other errors are processed here.
           # 13-some unknown app?
           # 62-"command not found" freshclam log folders not set up.
           # [!0]-not zero, any non-zero error number.
           case $APP_NAME in  # Start of sudo-error case statement
                sudo' '*)
                # Display error message.
                f_display_error_code
                echo
                echo "Try running \"$APP_NAME_TMP\" without the sudo command."
                echo "There is a possibility that the application is not installed."
                ;;
                *)
                # Display error message.
                f_display_error_code
                echo
                echo "Run \"$APP_NAME\" again this time using sudo?"
                echo -n "Use sudo (temporary root permissions)? (y/N): "
                read ANS
                case $ANS in  # Start of Use SUDO case statement.
                     [Yy] | [Yy][Ee] | [Yy][Ee][Ss])
                     APP_NAME_SUDO=$APP_NAME # Don't modify APP_NAME
                     sudo $APP_NAME_SUDO
                     ERROR=$? # Save error flag condition.
                     # Error code 1 $?=1 means sudo failed.
                     # Error code 0 (zero) where $?=0 means no error.
                     #
                     if [ $ERROR -ne 0 ] ; then
                        # Error after running with sudo?
                        # Display error message.
                        f_display_error_code
                        #
                        # Use different color font for error messages.
                        f_term_color $ECOLOR $BCOLOR
                        echo $(tput bold)
                        #
                        echo "Running \"sudo $APP_NAME_SUDO\" failed."
                        #
                        echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
                        echo "May be caused by bad sudo password, or user has no permission to use sudo,"
                        echo "or bad $APP_NAME_TMP syntax."
                        echo "Consult help using \"man $APP_NAME_TMP\"."
                        echo
                     fi
                     ;;
                     [Nn] | [Nn][Oo] | *)
                     ERROR=0
                     ;;
                esac # End of Use SUDO case statement.
                unset ANS  # Throw out this variable.
                ;;
           esac # End of sudo-error case statement
           ;;
      esac # End of Error Number case statement.
      # This function needs to be followed by a f_press_enter_key_to_continue
      # or by a f_option_press_enter_key so that messages are displayed.
      unset APP_NAME_TMP
} # End of function f_application_error
#
# +----------------------------------------+
# |     Function f_display_error_code      |
# +----------------------------------------+
#
#  Inputs: ERROR, APP_NAME_TMP.
#    Uses: None.
# Outputs: None.
#
f_display_error_code () {
      #
      # Use different color font for error messages.
      f_term_color $ECOLOR $BCOLOR
      echo -n $(tput bold)
      echo "**********************************************************************"
      echo ">>>>>>>>>> SEE ABOVE for application error messages, if any <<<<<<<<<<"
      echo "**********************************************************************"
      echo
      echo "          ***********"
      echo "Error code >>> $ERROR <<<  from \"$APP_NAME_TMP\" application."
      echo "          ***********"
      echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
} # End of function f_display_error_code
#
# +----------------------------------------+
# | Function f_application_install_question|
# +----------------------------------------+
#
#  Inputs: APP_NAME
#    Uses: INSTALL_ANS.
# Outputs: ERROR, PRESS_KEY.
#
f_application_install_question () {
                 echo -n "Do you want to install \"$APP_NAME\"? (y/N): "
                 read INSTALL_ANS
                 echo
                 # Start of Install Application Option case statement.
                 case $INSTALL_ANS in
                      [Yy] | [Yy][Ee] | [Yy][Ee][Ss])
                      # Yes, install the application.
                      INSTALL_ANS="YES"
                      f_application_install
                      ;;              
                      [Nn] | [Nn][Oo] | *)
                      # No, do not install the application.
                      INSTALL_ANS="NO"
                      ERROR=0
                      PRESS_KEY=0
                      # Do not display "Press 'Enter' key to continue."
                      ;;
                 esac # End of Install Application Option case statement.
                 unset INSTALL_ANS  # Throw out this variable.
} # End of function f_application_install_question
#
# +----------------------------------------+
# |     Function f_application_install     |
# +----------------------------------------+
#
#  Inputs: APP_NAME, FCOLOR, BCOLOR, ECOLOR.
#    Uses: None.
# Outputs: ERROR, APP_NAME_INSTALL, XSTR.
#
f_application_install () {
      #
      # 1. Strip off "sudo" or "run-time parameters" from $APP_NAME to get
      #    basic application name.
      # 2. Since the application name may not match the software package name,
      #    get the corresponding package name used by the distro's software
      #    package manager.
      # 3. Try installing application using distro's software package manager.
      #    Determine which application installation manager is used 
      #    by checking if the requisite directory exists.
      # 4. Install successful? Yes, DONE AND EXIT.
      # 5. No, install failed, display error message and then check for a
      #    custom install function.
      # 6. Is there a custom install function specified in the menu?
      #    No, skip to step 9.
      # 7. Yes, try to install again by using the custom install function.
      #    Custom install function format: f_install_<application name>.
      #    (Usually a custom install function will download source code
      #    from web and then compile it).
      # 8. Did custom install succeed? Yes, DONE AND EXIT.
      # 9. Is a maintainer's web site specified by lib_cli-web-sites.lib?
      #    No, DONE AND EXIT
      # 10. Yes, does user want to download application source code from the
      #     maintainer's web site?
      # 11. Yes, download source code and leave it to the user
      #     to manually compile.
      #
      APP_NAME_INSTALL=$APP_NAME 
      # Default of APP_NAME_INSTALL is simply APP_NAME. 
      # This may be modified below in the Installation Package Name
      # case statement.
      #
      # 1. Strip off "sudo" or "run-time parameters" from $APP_NAME to get
      #    basic application name.
      case $APP_NAME_INSTALL in # Start of APP_NAME_INSTALL case statement.
           *' '*)  
           # If string APP_NAME/APP_NAME_INSTALL includes spaces for
           # run-time parameters, then just extract package name.
           # i.e. "dstat 1 10", then extract "dstat" as package name.
           # i.e. "dstat --version", then extract "dstat" as package name.
           #
           APP_NAME_INSTALL=$(echo $APP_NAME_INSTALL | awk '{print $1;}')
           ;;
      esac # End of APP_NAME_INSTALL case statement.
      #
      # 2. Since the application name may not match the software package name,
      #    get the corresponding package name used by the distro's software
      #    package manager.
      f_match_pkg_name_to_app_name
      #
      # 3. Try installing application using distro's software package manager.
      #    Determine which application installation manager is used 
      #    by checking if the requisite directory exists.
      #
      # 4 to 11. Are included in code below.
      #
         # If /etc/apt directory exists, then use apt-get install
         # for Debian-based packages.
      if [ -d /etc/apt ] ; then 
         f_install_using_apt
         #
         # If <slackware Linux installation directory> exists,
         # then use slackpkg or installpkg for slackware packages.
      elif [ -d /var/lib/slackpkg ] ; then
         # f_install_using_slackpkg 
         echo
         # This if statement is commented out because slackpkg has
         # error code $?=0 even if the install fails.
         #
         # If <slackware Linux installation directory> exists,
         # then use slackpkg or installpkg for slackware packages.
      elif [ -d /var/lib/installpkg ] ; then
         # f_install_using_installpkg 
         echo
         # This if statement is commented out because slackpkg has
         # error code $?=0 even if the install fails.
         #
         # if <arch Linux installation directory> exists, then use pacman
         # for arch Linux packages.
      elif [ -d /var/lib/pacman ] ; then
         f_install_using_pacman
         #
         # if /var/lib/rpm directory exists, then use rpm install
         # for RPM-based packages.
         # rpm is last because some Slackware-based distros have
         # rpm directories also.
      elif [ -d /var/lib/rpm ] ; then 
         f_install_using_rpm
         #
      else
         f_install_using_no_auto
         #
      fi
      #
      if [ "$ERROR" -ne 0 ] ; then
         # If install via package manager failed then see if there is a custom
         # install function.
         # If 2nd field is a "1" then custom installation function exists.
         #
         # awk extracts the 2nd field from $MENU_ITEM_OPT.
         XSTR=$(echo $MENU_ITEM_OPT | awk -F "^" '{print $2}')
         #
         # If custom install function exists, run it.
         # $XSTR can either be 0, 1, "f_<custom install name>".
         if [ "$XSTR" != 0 ] ; then
            # Reset $ERROR to detect if custom install function fails.
            ERROR=0
            echo
            echo "Attempting to automatically download/install from source code, if possible."
            echo
            echo "Messages on the progress of the install should appear below."
            f_press_enter_key_to_continue
            f_eval_funct "$MENU_ITEM_OPT" 2
            if [ $ERROR -ne 0 ] ; then
               # Error code 1 $?=1 means custom installation failed.
               # Error code 0 (zero) where $?=0 means no error.
               # If install via custom install function failed then
               # see if there is a web install function.
               # Use different color font for error messages.
               f_term_color $ECOLOR $BCOLOR
               echo -n $(tput bold)
               echo
               echo --------------------------------------------------------------------------
               echo "The automatic download/install from source code failed somehow..."
               #
               echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
               f_web_install
            fi
         else
            # If custom install function does not exist,
            # does a web install function exist?
            # Is there a known web site with the source code?
            # If web install function exists, run it.
            f_web_install         
         fi
      fi
} # End of function f_application_install
#
# +----------------------------------------+
# |         Function f_web_install         |
# +----------------------------------------+
#
#  Inputs: WEB_SITE_INSTALL, APP_NAME, FCOLOR, BCOLOR, ECOLOR.
#    Uses: ANS.
# Outputs: ERROR, PRESS_KEY, APP_NAME_TMP.
#
f_web_install () {
      # Does a web install function exist?
      f_application_web_install
      #
      # Value of $WEB_SITE_INSTALL
      # ""              No web site is specified.
      # <web site name> Web site of application source code

      #  if a web install function exists run it.
      if [ -n "$WEB_SITE_INSTALL" ] ; then
         #
         echo
         echo "Do want to use the elinks web browser to visit the project's web site"
         echo -n "and download the application manually? (y/N): "
         read ANS
         case $ANS in # Start of Install case statement.
              [Yy] | [Yy][Ee] | [Yy][Ee][Ss])
              clear  # Blank the screen.
              echo "IMPORTANT:"
              echo "When using the elinks web browser, select \"Save\" to download a file."
              f_press_enter_key_to_continue
              APP_NAME_TMP="$APP_NAME" # Save name of application that did not
                                       # install properly.
              APP_NAME="elinks $WEB_SITE_INSTALL"
              f_how_to_quit_application "q"
              f_application_run
              APP_NAME="$APP_NAME_TMP" # Restore name of application that
                                       # did not install properly.
              PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
              ;;
              [Nn] | [Nn][Oo] | *)
              PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
              ;;
         esac # End of Install case statement.
         unset ANS  # Throw out this variable.
      else
         #
         # Use different color font for error messages.
         f_term_color $ECOLOR $BCOLOR
         echo -n $(tput bold)
         echo
         echo --------------------------------------------------------------------------
         echo "I failed to automatically download the source code as I don't know where"
         echo "to get it from."
         echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
         echo
         echo "You will have to do an Internet search to find a web site to download the"
         echo "software. Please be sure to download from a reputable web site."
         PRESS_KEY=1 # Display "Press 'Enter' key to continue."
      fi
} # End of function f_web_install
#
# +----------------------------------------+
# | Function f_match_pkg_name_to_app_name  |
# +----------------------------------------+
#
#  Inputs: APP_NAME_INSTALL, FCOLOR, BCOLOR, ECOLOR.
#    Uses: None.
# Outputs: APP_NAME_INSTALL.
#
# Below are cases where the APP_NAME is not the same as the
# package name used to install the application.
# i.e. The game 'trek' is installed using the package called 'bsdgames'.
#
f_match_pkg_name_to_app_name () {
      case $APP_NAME_INSTALL in # Start of Match Name case statement.
           aafire | aainfo | aatest | aasavefont)
           APP_NAME_INSTALL="libaa-bin"
           ;;
           aaxine | cacaxine | fbxine)
           APP_NAME_INSTALL="xine-console"
           ;;
           abc2midi | midi2abc | abc2abc | mftext | midicopy)
           APP_NAME_INSTALL="abcmidi"
           ;;
           acat| als | apack | atool | aunpack)
           APP_NAME_INSTALL="atool"
           ;;
           adventure | arithmetic | atc | backgammon | battlestar | bcd | boggle | caesar | canfield | countmail | cribbage | dab | go-fish | gomoku | hack | hangman | hunt | mille | monop | morse | number | pig | phantasia | pom | ppt | primes | quiz | random | rain | robots | rot13 | sail | snake | tetris | trek | wargames | worm | worms | wump | wtf)
           APP_NAME_INSTALL="bsdgames"
           ;;
           ag)
           # If /etc/apt directory exists, then use Debian package name.
           if [ -d /etc/apt ] ; then 
              APP_NAME_INSTALL="silversearcher-ag"
           fi
           ;;
           animate | composite | compare | conjure | convert | display | identify | import | mogrify | montage | stream)
           APP_NAME_INSTALL="imagemagick"
           ;;
           aria2c)
           APP_NAME_INSTALL="aria2"
           ;;
           barnowl | zcrypt)
           APP_NAME_INSTALL="barnowl"
           ;;
           binhex | frommac | hexbin | macunpack | macsave | macstream | tomac)
           APP_NAME_INSTALL="macutils"
           ;;
           cdrecord | readcd | cdda2wav | dirsplit | mkisofs | isodebug | isodump |  isoinfo | isovfy | rscsi)
           APP_NAME_INSTALL="cdrtools"
           ;;
           checkbashisms)
           APP_NAME_INSTALL="devscripts"
           ;;
           clamscan)
           APP_NAME_INSTALL="clamav"
           ;;
           dadd | dconv | ddiff | dgrep | dround | dseq | dtest)
           APP_NAME_INSTALL="dateutils"
           ;;
           exiftool)
           APP_NAME_INSTALL="libimage-exiftool-perl"
           ;;
           e3*) # covers e3em, e3vi, e3pi, e3ne, e3ws.
           APP_NAME_INSTALL="e3"
           ;;
           fbgs | fbi | ida | exiftran)
           APP_NAME_INSTALL="fbi"
           ;;
           fd)
           APP_NAME_INSTALL="fdclone"
           ;;
           geoiplookup)
           APP_NAME_INSTALL="geoip-bin"
           ;;
           gitfm | gitps | gitview | gitwipe | gitkeys | gitmount | gitaction | gitunpack | gitrgrep | gitregrep | gitrfgrep)
           APP_NAME_INSTALL="gnuit"
           ;;
           ifplugstatus)
           APP_NAME_INSTALL="ifplugd"
           ;;
           jstar | jmacs | jpico | rjoe)
           APP_NAME_INSTALL="joe"
           ;;
           lastb)
           APP_NAME_INSTALL="last"
           ;;
           lynx)
           APP_NAME_INSTALL="lynx-cur"
           ;;
           mattrib | mbadblocks | mcat | mcd | mclasserase | mcopy | mdel | mdeltree | mdir | mdoctorfat | mdu | mformat | minfo | mlabel | mmd | mmount | mpartition | mrd | mread | mmove | mren | mshowfat | mshortname | mtoolstest | mtype | mwrite | mzip)
           APP_NAME_INSTALL="mtools"
           ;;
           moc)
           APP_NAME_INSTALL="libqt4-dev"
           ;;
           mpstat | iostat | pidstat | sadf | sar)
           APP_NAME_INSTALL="sysstat"
           ;;
           nagios3)
           APP_NAME_INSTALL="nagios3-core"
           ;;
           npush | npull)
           APP_NAME_INSTALL="ncp"
           ;;
           photorec)
           APP_NAME_INSTALL="testdisk"
           ;;
           qmv | qcp | imv | icp | deurlname)
           APP_NAME_INSTALL="renameutils"
           ;;
           tcpblast | netload | trafshow | netwatch | strobe | statnet | tcpspray)
           APP_NAME_INSTALL="netdiag"
           ;;
           tide | xtide)
           APP_NAME_INSTALL="xtide"
           ;;
           todo | todo2)
           APP_NAME_INSTALL="devtodo"
           ;;
           trek73)
           APP_NAME_INSTALL="trekx"
           ;;
           ttyplay)
           APP_NAME_INSTALL="ttyrec"
           ;;
           weather)
           APP_NAME_INSTALL="weather-util"
           ;;
           xz | unxz | xzcat | xzgrep)
           APP_NAME_INSTALL="xz-utils"
           ;;
      esac # End of Match Name case statement.
} # End of function f_match_pkg_name_to_app_name
#
# +----------------------------------------+
# |      Function f_install_using_apt      |
# +----------------------------------------+
#
#  Inputs: APP_NAME_INSTALL, FCOLOR, BCOLOR, ECOLOR.
#    Uses: None.
# Outputs: ERROR.
#
f_install_using_apt () {
      sudo apt-get install $APP_NAME_INSTALL
      ERROR=$? # Save error flag condition.
      if [ $ERROR -ne 0 ] ; then
         # Error code 1 $?=1 means installation failed.
         # Error code 0 (zero) where $?=0 means no error.
         #
         # Use different color font for error messages.
         f_term_color $ECOLOR $BCOLOR
         echo -n $(tput bold)
         echo "Command \"sudo apt-get install $APP_NAME_INSTALL\" failed."
         echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
         echo "Perhaps the software package \"$APP_NAME_INSTALL\""
         echo "is not pre-packaged in the software repositories for this Linux distribution."
         echo
         f_app_install_mssg
         #
      fi
} # End of function f_install_using_apt
#
# +----------------------------------------+
# |   Function f_install_using_slackpkg    |
# +----------------------------------------+
#
#  Inputs: APP_NAME_INSTALL, FCOLOR, BCOLOR, ECOLOR, MENU_ITEM_OPT.
#    Uses: None.
# Outputs: ERROR.
#
f_install_using_slackpkg () {
      sudo slackpkg install $APP_NAME_INSTALL
      ERROR=$? # Save error flag condition.
      # To Do List: find a way to indicate a failed install
      # and alter if statement below.
      #
      if [ $ERROR -ne 0 ] ; then
         # Error code 1 $?=1 means installation failed.
         # Error code 0 (zero) where $?=0 means no error.
         echo -n $(tput bold)
         #
         # Use different color font for error messages.
         f_term_color $ECOLOR $BCOLOR
         echo -n $(tput bold)
         echo "Command \"sudo slackpkg $APP_NAME_INSTALL\" failed."
         echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
         echo "Perhaps the software package \"$APP_NAME_INSTALL\""
         echo "is not pre-packaged in the software repositories for this Linux distribution."
         echo
         f_app_install_mssg
         # If install via package manager failed then see if there is a
         # custom install function.
         # If 2nd field is a "1" then <f_install_app-name> is a
         # custom installation function.
         #
         # Reset $ERROR to detect if custom install function fails.
         ERROR=0
         f_eval_funct "$MENU_ITEM_OPT" 2
         #
         if [ $ERROR -ne 0 ] ; then
            # Error code 1 $?=1 means custom installation failed.
            # Error code 0 (zero) where $?=0 means no error.
            #
            # Try downloading source code from a web site
            # and manually installing.
            f_application_web_install  # Forced output PRESS_KEY=0.
         fi
      fi
} # End of function f_install_using_apt
#
# +----------------------------------------+
# |  Function f_install_using_installkpkg  |
# +----------------------------------------+
#
#  Inputs: APP_NAME_INSTALL, FCOLOR, BCOLOR, ECOLOR, MENU_ITEM_OPT.
#    Uses: None.
# Outputs: ERROR.
#
f_install_using_installpkg () {
      sudo installpkg install $APP_NAME_INSTALL
      ERROR=$? # Save error flag condition.
      # 
      # This if statement is commented out because slackpkg
      #  has error code $?=0 even if install fails.
      # 
      # To Do List: find a way to indicate a failed install
      # and alter if statement below.
      #
      if [ $ERROR -ne 0 ] ; then
         # Error code 1 $?=1 means installation failed.
         # Error code 0 (zero) where $?=0 means no error.
         echo -n $(tput bold)
         #
         # Use different color font for error messages.
         f_term_color $ECOLOR $BCOLOR
         echo -n $(tput bold)
         echo "Command \"sudo slackpkg $APP_NAME_INSTALL\" failed."
         echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
         echo "Perhaps the software package \"$APP_NAME_INSTALL\""
         echo "is not pre-packaged in the software repositories for this Linux distribution."
         echo
         f_app_install_mssg
         #
         # If install via package manager failed then see if there is a
         # custom install function.
         # If 2nd field is a "1" then <f_install_app-name> is a
         # custom installation function.
         #
         # Reset $ERROR to detect if custom install function fails.
         ERROR=0
         f_eval_funct "$MENU_ITEM_OPT" 2
         #
         if [ $ERROR -ne 0 ] ; then
            # Error code 1 $?=1 means custom installation failed.
            # Error code 0 (zero) where $?=0 means no error.
            #
            # Try downloading source code from a web site
            # and manually installing.
            f_application_web_install  # Forced output PRESS_KEY=0.
         fi
      fi
} # End of function f_install_using_installpkg
#
# +----------------------------------------+
# |     Function f_install_using_pacman    |
# +----------------------------------------+
#
#  Inputs: APP_NAME_INSTALL, FCOLOR, BCOLOR, ECOLOR, MENU_ITEM_OPT.
#    Uses: None.
# Outputs: ERROR.
#
f_install_using_pacman () {
      sudo pacman -S $APP_NAME_INSTALL
      ERROR=$? # Save error flag condition.
      if [ $ERROR -ne 0 ] ; then
         # Error code 1 $?=1 means installation failed.
         # Error code 0 (zero) where $?=0 means no error.
         #
         # Use different color font for error messages.
         f_term_color $ECOLOR $BCOLOR
         echo -n $(tput bold)
         echo "Command \"sudo pacman -S $APP_NAME_INSTALL\" failed."
         echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
         echo "Perhaps the software package \"$APP_NAME_INSTALL\""
         echo "is not pre-packaged in the software repositories for this Linux distribution."
         echo 
         f_app_install_mssg
         #
         # If install via package manager failed then see if there is a
         # custom install function.
         # If 2nd field is a "1" then <f_install_app-name> is a
         # custom installation function.
         #
         # Reset $ERROR to detect if custom install function fails.
         ERROR=0
         f_eval_funct "$MENU_ITEM_OPT" 2
         #
         if [ $ERROR -ne 0 ] ; then
            # Error code 1 $?=1 means installation failed.
            # Error code 0 (zero) where $?=0 means no error.
            #
            # Try downloading source code from a web site
            # and manually installing.
            f_application_web_install  # Forced output PRESS_KEY=0.
         fi
      fi
      #
} # End of function f_install_using_pacman
#
# +----------------------------------------+
# |       Function f_install_using_rpm     |
# +----------------------------------------+
#
#  Inputs: APP_NAME_INSTALL, FCOLOR, BCOLOR, ECOLOR, MENU_ITEM_OPT.
#    Uses: None.
# Outputs: ERROR.
#
f_install_using_rpm () {
         sudo rpm -ivh $APP_NAME_INSTALL 
         ERROR=$? # Save error flag condition.
         if [ $ERROR -ne 0 ] ; then
            # Error code 1 $?=1 means installation failed.
            # Error code 0 (zero) where $?=0 means no error.
            #
            # Use different color font for error messages.
            f_term_color $ECOLOR $BCOLOR
            echo -n $(tput bold)
            echo "Command \"sudo rpm -ivh $APP_NAME_INSTALL\" failed."
            echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
            echo "Perhaps the software package \"$APP_NAME_INSTALL\""
            echo "is not pre-packaged in the software repositories for this Linux distribution."
            echo
            f_app_install_mssg
            #
            # If install via package manager failed then see if there is a
            # custom install function.
            # If 2nd field is a "1" then <f_install_app-name> is a
            # custom installation function.
            #
            # Reset $ERROR to detect if custom install function fails.
            ERROR=0
            f_eval_funct "$MENU_ITEM_OPT" 2
            #
            if [ $ERROR -ne 0 ] ; then
               # Error code 1 $?=1 means custom installation failed.
               # Error code 0 (zero) where $?=0 means no error.
               #
               # Try downloading source code from a web site
               # and manually installing.
               f_application_web_install  # Forced output PRESS_KEY=0.
            fi
         fi
} # End of function f_install_using_rpm
#
# +----------------------------------------+
# |    Function f_install_using_no_auto    |
# +----------------------------------------+
#
#  Inputs: APP_NAME_INSTALL, FCOLOR, BCOLOR, ECOLOR, MENU_ITEM_OPT.
#    Uses: None.
# Outputs: ERROR.
#
f_install_using_no_auto () {
      # Use different color font for error messages.
      f_term_color $ECOLOR $BCOLOR
      echo -n $(tput bold)
      echo "You will have to install the $APP_NAME_INSTALL package manually."
      echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
      echo "Automatic install is only available for apt, rpm, slackpkg, pacman package managers."
      echo
      f_app_install_mssg
      #
      # If install via package manager failed then see if there is a
      # custom install function.
      # If 2nd field is a "1" then <f_install_app-name> is a
      # custom installation function.
      #
      # Reset $ERROR to detect if custom install function fails.
      ERROR=0
      f_eval_funct "$MENU_ITEM_OPT" 2
      #
      if [ $ERROR -ne 0 ] ; then
         # Error code 1 $?=1 means custom installation failed.
         # Error code 0 (zero) where $?=0 means no error.
         #
         # Try downloading source code from a web site
         # and manually installing.
         f_application_web_install  # Forced output PRESS_KEY=0.
      fi
      #
} # End of function f_install_using_no_auto
#
# +----------------------------------------+
# |      Function f_app_install_mssg       |
# +----------------------------------------+
#
#  Inputs: None.
#    Uses: None.
# Outputs: None.
#
f_app_install_mssg () {
      echo
      echo "Not all Linux distributions include all applications featured in this menu."
      echo
      echo "i.e. An application or software package that is available in the Red Hat Linux"
      echo "     distribution may not be available in the Debian Linux distribution,"
      echo "     and vice versa."
      echo
      #
} # End of function f_app_install_mssg
#
# +----------------------------------------+
# |   Function f_test_internet_connection  |
# +----------------------------------------+
#
#  Inputs: MOD_FILE, FCOLOR, BCOLOR, ECOLOR.
#    Uses: None.
# Outputs: ERROR.
#
f_test_internet_connection () {
      # Check if there is an Internet connection before doing a download.
      echo
      echo "Test Internet connection:"
      ping -c 1 -q 8.8.4.4  # Ping Google.com DNS address.
      ERROR=$?
      #
      if [ $ERROR -ne 0 ] ; then
         f_term_color $ECOLOR $BCOLOR
         echo -n $(tput bold)
         echo "Test of Internet connnection failed, the Internet may be disconnected."
         if [ -n "$MOD_FILE" ] ; then
            echo -n "Cannot download \"$MOD_FILE\" at this time."
         fi
         #
         echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
         #
         # Design choice not to insert message "Press 'Enter' key to continue."
         # to allow display of additional error messages on the same screen.
      fi
} # End of function f_test_internet_connection
#
# +----------------------------------------+
# |       Function f_download_file         |
# +----------------------------------------+
#
#  Inputs: BRANCH, THIS_DIR, MOD_FILE.
#    Uses: None.
# Outputs: PRESS_KEY.
#
# Download a single file $MOD_FILE from $WEB_SITE.
#
f_download_file () {
      PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
      . lib_cli-common.lib # Invoke the common library.
      #
      case $MOD_FILE in
           mod_apps*.lib)  # Module files only
           # Ask download from which branch and wget.
           f_wget_file
           #
           # Check to see if download was successful before invoking module.
           if [ "$BRANCH" != "SKIP" ] && [ -r $THIS_DIR/$MOD_FILE ] ; then
              # $MOD_FILE exists in current directory so make it accessible.
              . $THIS_DIR/$MOD_FILE # Invoke module library.
           fi
           ;;
           *)  # All other files.
           # Ask download from which branch and wget.
           f_wget_file
           ;;
      esac
} # End of f_download_file
#
# +----------------------------------------+
# |       Function f_wget_file             |
# +----------------------------------------+
#
#  Inputs: None.
#    Uses: None.
# Outputs: None.
#
# wget a single file $MOD_FILE from $WEB_SITE.
#
f_wget_file () {
      # Always ask what branch from which to download.
      # Download from which git branch, DEVELOPMENT, TESTING or MASTER?
      f_ask_which_branch_download
      #
      # Libraries invoked so that functions in the module management library
      # may be accessed when doing a program update.
      # This prevents "<function name> command not found" error messages.
      #
      . lib_cli-common.lib # Invoke the common library.
      . lib_cli-menu-cat.lib # Invoke the module management library.
      f_wget_file_2
      #
} # End of f_wget_file
#
# +----------------------------------------+
# |      Function f_wget_file_2            |
# +----------------------------------------+
#
#  Inputs: BRANCH, MOD_FILE, MAINMENU_DIR, THIS_DIR.
#    Uses: XXSTR.
# Outputs: ERROR.
#
# wget a single file $MOD_FILE from $WEB_SITE.
#
f_wget_file_2 () {
      # Beforehand, always ask what branch from which to download.
      #
      # The wget --directory-prefix allows file to be downloaded into a
      # specific directory.
      #
      ERROR=0
      if [ "$BRANCH" != "SKIP" ] ; then
         if [ "$MOD_FILE" = "cliappmenu.sh" ] ; then
            XXSTR=$THIS_DIR         # Save $THIS_DIR location of other files.
                                    # module libraries etc.
            THIS_DIR=$MAINMENU_DIR  # Set $THIS_DIR to location of Main Menu.
         fi
         #
         # Backup file
         f_backup_file $THIS_DIR $MOD_FILE
         if [ $ERROR -eq 0 ] || [ $ERROR -eq 2 ] ; then
            # ERROR=0 Back-up successful so remove file.
            # ERROR=2 File does not exist so not backed up
            #         but still needs to be downloaded.
            #
            if [ $ERROR -eq 0 ] ; then
               # Only remove file if file exists and was backed up.
               # If only a backup exists (*.tar.gz) then remove is not needed.
               f_remove_file $THIS_DIR $MOD_FILE
            fi
            #
            if [ $ERROR -eq 2 ] ; then
               # If only a backup exists (*.tar.gz) then also allow download.
               ERROR=0
            fi
            #
            if [ $ERROR -eq 0 ] ; then
               # Remove file successful so download new file.
               # Now only the back-up file *.tar.gz is in the directory.
               f_wget_file_3
               if [ $ERROR -eq 0 ] ; then
                  # Download successful so delete back-up.
                  f_remove_file $THIS_DIR $MOD_FILE.tar.gz
               else
                  # Download failed so restore back-up.
                  f_restore_file $THIS_DIR $MOD_FILE
                  if [ $ERROR -eq 0 ] ; then
                     # Restore successful so delete back-up.
                     f_remove_file $THIS_DIR $MOD_FILE.tar.gz
                  fi
               fi   
            fi
            #
            if [ "$MOD_FILE" = "cliappmenu.sh" ] ; then
               THIS_DIR=$XXSTR  # Restore original THIS_DIR.
            fi
         fi
      fi
      unset XXSTR
} # End of f_wget_file_2
#
# +----------------------------------------+
# |      Function f_backup_file            |
# +----------------------------------------+
#
#  Inputs: $1=Directory, $2=File, ERROR, FCOLOR, BCOLOR, ECOLOR.
#    Note: $2 is file name (without suffix tar.gz).
#    Uses: None.
# Outputs: None.
#
# Back-up a single file $2 to a compressed file $2.tar.gz.
#
f_backup_file () {
      f_module_archive $1 $2
      # ERROR=1 if tar back-up fails.
      # ERROR=2 if file to be backed-up does not exist.
      #
      if [ $ERROR -eq 1 ] ; then
         f_term_color $ECOLOR $BCOLOR
         echo $(tput bold)
         #
         echo "Error making back-up file \"$2.tar.gz\"."
         #
         echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
      fi
} # End of f_backup_file
#
# +----------------------------------------+
# |      Function f_restore_file           |
# +----------------------------------------+
#
#  Inputs: $1=Directory, $2=File, ERROR, FCOLOR, BCOLOR, ECOLOR.
#    Note: $2 is file name (without suffix tar.gz).
#    Uses: None.
# Outputs: None.
#
# Restore a single compressed file $2.tar.gz to an uncompressed file $2.
#
f_restore_file () {
      f_module_restore $1 $2
      # ERROR=1 if tar restore fails.
      # ERROR=2 if file to be restored does not exist.
      #
      if [ $ERROR -eq 1 ] ; then
         f_term_color $ECOLOR $BCOLOR
         echo $(tput bold)
         #
         echo "Error restoring file \"$2\"."
         #
         echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
      fi
} # End of f_restore_file
#
# +----------------------------------------+
# |      Function f_remove_file            |
# +----------------------------------------+
#
#  Inputs: $1=Directory, $2=File.
#    Note: $2 is the full file name including any extensions.
#    Uses: None.
# Outputs: None.
#
# Remove a single file $MOD_FILE.
#
f_remove_file () {
      f_module_remove $1 $2
      # ERROR=1 if file deletion fails.
      # ERROR=2 if file to be deleted does not exist.
      #
} # End of f_remove_file
#
# +----------------------------------------+
# |      Function f_wget_file_3            |
# +----------------------------------------+
#
#  Inputs: BRANCH, MOD_FILE, THIS_DIR, WEB_SITE.
#    Uses: None.
# Outputs: ERROR.
#
# wget a single file $MOD_FILE from $WEB_SITE.
#
f_wget_file_3 () {
      ERROR=0
      #
      # Download the module except if file is "cli-app-menu.sh".
      # Is directory writable?
      if [ -w $THIS_DIR ] ; then
         # Yes, directory is writable.
         # Does file exist?
         if [ -w $THIS_DIR/$MOD_FILE ] ; then
            wget --directory-prefix=$THIS_DIR $WEB_SITE$MOD_FILE
            ERROR=$?
         else
            if [ -e $THIS_DIR/$MOD_FILE ] ; then
               # Need sudo permissions to download file.
               sudo wget --directory-prefix=$THIS_DIR $WEB_SITE$MOD_FILE
               ERROR=$?
            else
               # File does not exist
               wget --directory-prefix=$THIS_DIR $WEB_SITE$MOD_FILE
               ERROR=$?
            fi
         fi
      else
         # No, directory is not writable.
         # Need sudo permissions to download file.
         sudo wget --directory-prefix=$THIS_DIR $WEB_SITE$MOD_FILE
         ERROR=$?
      fi
      #
      if [ $ERROR -ne 0 ] ; then
         f_term_color $ECOLOR $BCOLOR
         echo $(tput bold)
         #
         echo "Error downloading file \"$MOD_FILE\"."
         #
         echo -n $(tput sgr0) ; f_term_color $FCOLOR $BCOLOR ; echo -n $(tput bold)
         echo
      else
         echo "Downloaded file, \"$MOD_FILE\" from github \"$BRANCH\" branch." 
         echo
      fi
} # End of function f_wget_file_3
#
# +----------------------------------------+
# |  Function f_ask_which_branch_download  |
# +----------------------------------------+
#
#  Inputs: BRANCH.
#    Uses: ANS, XSTR.
# Outputs: BRANCH, WEB_SITE, PRESS_KEY.
#
f_ask_which_branch_download () {
      XSTR="(MASTER/testing/develop/skip)"  # Set default prompt options.
      case $BRANCH in
           "" | [MM] | [Mm][Aa] | [Mm][Aa][Ss]*)
           XSTR="(MASTER/testing/develop/skip)"
           ;;
           [Tt] | [Tt][Ee] | [Tt][Ee][Ss]*)
           XSTR="(master/TESTING/develop/skip)"
           ;;                  
           [Dd] | [Dd][Ee] | [Dd][Ee][Vv]*)
           XSTR="(master/testing/DEVELOP/skip)"
           ;;
           [Ss] | [Ss][Kk] | [Ss][Kk][Ii] | [Ss][Kk][Ii][Pp])
           XSTR="(master/testing/develop/SKIP)"
           ;;                  
      esac
      #
      ANS=""
      while [  "$ANS" != "MASTER" ] && [ "$ANS" != "TESTING" ] && [ "$ANS" != "DEVELOP" ] && [ "$ANS" != "SKIP" ]
      do
            echo "Download from which cli-app-menu project branch hosted on GitHub.com?"
            echo -n "$XSTR: "
            read ANS
            case $ANS in
                 [Mm] | [Mm][Aa] | [Mm][Aa][Ss]*)
                 WEB_SITE="https://raw.github.com/rdchin/CLI-app-menu/master/"
                 ANS="MASTER"
                 PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                 ;;
                 [Tt] | [Tt][Ee] | [Tt][Ee][Ss]*)
                 WEB_SITE="https://raw.github.com/rdchin/CLI-app-menu/testing/"
                 ANS="TESTING"
                 PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                 ;;                  
                 [Dd] | [Dd][Ee] | [Dd][Ee][Vv]*)
                 WEB_SITE="https://raw.github.com/rdchin/CLI-app-menu/develop/"
                 ANS="DEVELOP"
                 PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                 ;;
                 [Ss] | [Ss][Kk] | [Ss][Kk][Ii] | [Ss][Kk][Ii][Pp])
                 ANS="SKIP"
                 PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
                 ;;
                 "")  # When null answer, default to previous branch choice.
                 case $BRANCH in
                      ""| [MM] | [Mm][Aa] | [Mm][Aa][Ss]*)
                      WEB_SITE="https://raw.github.com/rdchin/CLI-app-menu/master/"
                      ANS="MASTER"
                      PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                      ;;                
                      [Tt] | [Tt][Ee] | [Tt][Ee][Ss]*)
                      WEB_SITE="https://raw.github.com/rdchin/CLI-app-menu/testing/"
                      ANS="TESTING"
                      PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                      ;;                  
                      [Dd] | [Dd][Ee] | [Dd][Ee][Vv]*)
                      WEB_SITE="https://raw.github.com/rdchin/CLI-app-menu/develop/"
                      ANS="DEVELOP"
                      PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                      ;;
                      [Ss] | [Ss][Kk] | [Ss][Kk][Ii] | [Ss][Kk][Ii][Pp])
                      ANS="SKIP"
                      PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
                      ;;
                 esac
                 ;;
            esac
      done
      BRANCH=$ANS  # Output $BRANCH.
      unset ANS XSTR  # Throw out this variable.
} # End of function f_ask_which_branch_download
#
# +----------------------------------------+
# |       Function f_create_LIST_APPS      |
# +----------------------------------------+
#
#  Inputs: THIS_DIR.
#    Uses: XSTR.
# Outputs: File LIST_APPS, MOD_FILE, MOD_FUNC, ERROR.
#
# File LIST_APPS may be recreated at any time from the command line.
# Prerequisite: README file and ALL module files, mod_apps-*.lib
#               MUST BE in the same directory as this lib_cli-common.lib file.
#
# General notes: 1. README file is read for #MXX (Special Menu Item Marker)
#                   type comments which include the menu name.
#                2. The Application Category Menu in file lib_cli-menu-cat.lib
#                   has the module library file names needed.
#                3. Search grep all module library files for the Special Menu
#                   Item Markers #MXX which are unique for each
#                   application menu.
#                4. Print result of application menu names with
#                   application names.
#
# To recreate LIST_APPS manually:
# Type this command (without double-quotation marks) at the CLI prompt:
# ". lib_cli-common.lib; f_create_LIST_APPS"
#  <dot><space>lib_cli-common.lib<semi-colon><space>f_create_LIST_APPS.
#
f_create_LIST_APPS () {
      # Generate file LIST_APPS by using grep on each module file.
      # Assumes all module files are present in current directory.
      #
      # Remove old LIST_APPS file.
      rm $THIS_DIR/LIST_APPS  &>/dev/null # Do not display any errors.
      ERROR=$?
      if [ $ERROR -eq 1 ] ; then
         sudo rm $THIS_DIR/LIST_APPS &>/dev/null # Do not display any errors
                                                 # due to non-existent file.
      fi
      echo "_______________________________________________________________________________" >> ~/LIST_APPS
      echo -n "Last updated: " >> ~/LIST_APPS 
      date +%Y-%m-%d" "%H:%M" "%A >> ~/LIST_APPS
      #
      # Explanation of the "for XSTR in" loop:
      #
      # 1. grep [#]:M[A-Z][A-Z] README
      #    Find all lines matching "#:M[A-Z][A-Z]" in the file README.
      #    This will find strings like "#:MAA - Accounting Applications Menu"
      #
      # 2. awk '{print $1}'
      #    Prints just the Special Menu Item Marker, "#:MAA" and XSTR="#:MAA".
      #
      # 3. grep $XSTR README
      #    Search README for all occurrences of the Special Menu Item Marker.
      #    Find all lines matching "#:MAA" in the file README.
      #    This will find strings like "#:MAA - Accounting Applications Menu"
      #
      # 4. awk -F " - " '{print $2}'
      #    Strips the ":#MAA - " from it: "Accounting Applications Menu"
      #
      # 6. awk '{sub("Menu","Menu ***"); print $0}'
      #    Appends "***" at the end: "Accounting Applications Menu ***"
      #
      # Set XSTR to the Special Menu Item Marker.
      for XSTR in $(grep [#]:M[A-Z][A-Z] $THIS_DIR/README | awk '{print $1}')
      do
          echo >> ~/LIST_APPS
          # Print application category menu title.
          echo "_______________________________________________________________________________" >> ~/LIST_APPS
          echo -n "*** " >> ~/LIST_APPS
          grep $XSTR $THIS_DIR/README | awk -F " - " '{print $2}'  | awk '{sub("Menu","Menu ***"); print $0}' >> ~/LIST_APPS
          #
          # Example for setting XSTR within the "for XSTR in" loop:
          # Set XSTR from "#:MPS" to "#MPS" Special Menu Item Marker.
          # XSTR="#:MPS" to grep README file for menu titles.
          # XSTR="#MPS"  to grep mod_apps*.lib files for application names
          #              and descriptions.
          # XSTR="MPS"   Did not work since README file contained the word
          #              "MUMPS" which caused problems when displaying the
          #              menu title for "#:MPS - PDF-PS Applications Menu".
          #
          # So somehow XSTR had to be modified within
          # the "for XSTR in" for-loop.
          #
          # Use string substitution, I just learned how, cool!
          XSTR=${XSTR/:/}
          # Allows change from XSTR=":MPS" to XSTR="MPS"
          # where the colon is stripped out.
          #
          # Print application names and descriptions.
          # Any new mod_apps*.lib files added must be included as menu items
          # in the Application Menu.
          #
          # The for-loop reads file "lib_cli-menu-cat.lib" to get the names
          # of the mod_apps*.lib files.
          # The for-loop awk command uses back-ticks to execute,
          # getting the names of mod_apps-*.lib.
          #
          # 1. awk -F "#AAB" '{if ($2&&!$3){print $1}}' $THIS_DIR/lib_cli-menu-cat.lib
          #    if-statement conditional "($2&&!$3)":
          #    Since the special comment marker is "#AAB",
          #    if there is 1 marker (2 fields) then print the 1st field.
          #    if there are 2 markers (3 fields), then do not print at all.
          #    This prevents the lines of code which set the $ DELIMITER
          #    variable from being printed as a menu item, because they
          #    purposely have 2 markers.
          #
          #    For menu item "#mod_apps-audio.lib #AAB Audio - Music players, editors, utilities."
          #    This will result in: "#mod_apps-audio.lib"
          #
          # 2. | awk -F "#" '{print $2}'
          #    The previous result is piped into this awk statement which
          #    simply strips out the "#".
          #    This will result in: MOD_FILE="mod_apps-audio.lib"
          #
          # To get the file name of the module, it must be derived from the name
          # of the function in the "Application Category Menu" or the
          # "Software Module Manager Menu" which share the same "#AAB" menu.
          #
          # The "for MOD_FILE in" loop cycles through all the module function
          # names and contains awk which looks for "#AAB" 1 marker only by using
          # the awk if-statement conditional statement, "($2&&!$3)", in the
          # file lib_cli-menu-cat.lib. The result is "#f_mod_apps_<module>"
          # and then this is piped to the second awk which strips away the "#f_"
          # leaving only "mod_apps_<module>".
          #
          # The result of awk is "mod_apps_<module>" so to get the file name,
          # MOD_FILE=$MOD_FILE.lib resulting in "mod_apps_<module>.lib".
          #
          # for-loop awk command uses back-ticks to execute resulting in a
          # function name which is then converted into a file name of the
          # module, mod_apps-*.lib.
          #
          for MOD_FUNC in `awk -F "#@@" '{print $5}' $THIS_DIR/menu_module_mod_management.lib`
          do
              #
              # The first menu option is usually "Exit" with a "function name" of "break".
              # Do not use function name, "break" as the file name at all.
              # This is taken care of by the test if file exists
              # "[ -e $THIS_DIR/$MOD_FILE ]" since there is no file name of "break".
              #
              # Convert the function name in the "Application Category Menu"
              # to a file name.
              #
              # The conversion is necessary because the file names may contain
              # <dash> characters while function names cannot under
              # non-bash shells (just trying to follow the naming convention).
              #
              MOD_FILE=$MOD_FUNC
              # Substitute <underscore> for <dash>.
              MOD_FILE=${MOD_FILE/mod_apps_/mod_apps-}
              # Substitution for audio-video.
              MOD_FILE=${MOD_FILE/audio_video/audio-video}
              # Substitution for screen-tools.
              MOD_FILE=${MOD_FILE/screen_tools/screen-tools}
              # Complete the <file name> change.
              MOD_FILE=$MOD_FILE.lib
              # Human readable list without special comment markers.
              # Indents one space before application name.
              #
              # 1. grep $XSTR $THIS_DIR/$MOD_FILE
              #    Search the files mod_apps-*.lib one at a time for the
              #    Special Menu Item Marker.
              #
              #    Example: Suppose XSTR="#MAA ".
              #    This will find strings like:
              #    "#MAA ledger        - Ledger using double-entry."
              #
              # 2. awk -F $XSTR '{if ($2&&!$3){print $2}}'
              #    if-statement conditional "($2&&!$3)":
              #    Since the $DELIMITER is part/all of the special comment
              #    marker,
              #    if there is 1 marker (2 fields) then print the 2nd field.
              #    if there are 2 markers (3 fields), then do not print.
              #    This prevents the lines of code which set the $ DELIMITER
              #    variable from being printed as a menu item, because they
              #    purposely have 2 markers.
              #    This will result in string with a leading space.
              #    " ledger - Ledger using double-entry." w/delimiter $XSTR.
              #
              if [ -e $THIS_DIR/$MOD_FILE ] ; then
                 grep $XSTR $THIS_DIR/$MOD_FILE | awk -F $XSTR '{if ($2&&!$3){print $2}}' >> ~/LIST_APPS
              fi
              #
              echo -n "." # Ellipses to indicate function is running displayed
                          # on screen display. Displays rows of "...".
          done
      done
      #
      echo "_________________________________End of List___________________________________" >> ~/LIST_APPS
      # Use sudo permissions if directory is not writable.
      if [ -w $THIS_DIR ] ; then
         cp ~/LIST_APPS $THIS_DIR/
         rm ~/LIST_APPS
      else
         sudo cp ~/LIST_APPS $THIS_DIR/
         rm ~/LIST_APPS
      fi
      unset XSTR  # Throw out this variable.
} # End of function f_create_LIST_APPS
#
# +----------------------------------------+
# |     Function f_reinstall_readme        |
# +----------------------------------------+
#
#  Inputs: GUI.
#    Uses: None.
# Outputs: None.
#
f_reinstall_readme () {
case $GUI in
     dialog | whiptail)
     f_reinstall_readme_gui
     ;;
     text)
     f_reinstall_readme_txt
     ;;
esac
} # End of f_main_code_history
#
# +----------------------------------------+
# |    Function f_reinstall_readme_txt     |
# +----------------------------------------+
#
#  Inputs: $1 - Directory. 
#    Uses: X.
# Outputs: None.
#
f_reinstall_readme_txt () {
      clear # Blank the screen.
      echo "To re-install this software into another location/directory,"
      echo "simply copy the file, "cliappmenu.sh" to the other directory."
      echo
      echo "        cp <old directory>/cliappmenu.sh <new directory>"
      echo "             or"
      echo  "       sudo cp <old directory>/cliappmenu.sh <new directory>"
      echo
      echo "Then change to the new directory and run the script."
      echo
      echo "        cd <new directory>"
      echo
      echo "        bash cliappmenu.sh"
      echo "             or"
      echo "        sudo bash cliappmenu.sh"
      echo
      echo "Then the mini-installer will automatically run and give you more instructions."
      echo
      echo -n "Press \"Enter\" key to continue." ; read X
      unset X

} # End of function f_reinstall_readme_txt
#
# +----------------------------------------+
# |    Function f_reinstall_readme_gui     |
# +----------------------------------------+
#
#  Inputs: $1 - Directory. 
#    Uses: None.
# Outputs: None.
#
f_reinstall_readme_gui () {
      echo "To re-install this software into another location/directory," >cliappmenu.tmp
      echo "simply copy the file, "cliappmenu.sh" to the other directory." >>cliappmenu.tmp
      echo >>cliappmenu.tmp
      echo "        cp <old directory>/cliappmenu.sh <new directory>" >>cliappmenu.tmp
      echo "             or" >>cliappmenu.tmp
      echo  "       sudo cp <old directory>/cliappmenu.sh <new directory>" >>cliappmenu.tmp
      echo >>cliappmenu.tmp
      echo "Then change to the new directory and run the script." >>cliappmenu.tmp
      echo >>cliappmenu.tmp
      echo "        cd <new directory>" >>cliappmenu.tmp
      echo >>cliappmenu.tmp
      echo "        bash cliappmenu.sh" >>cliappmenu.tmp
      echo "             or" >>cliappmenu.tmp
      echo "        sudo bash cliappmenu.sh" >>cliappmenu.tmp
      echo >>cliappmenu.tmp
      echo "Then the mini-installer will automatically run" >>cliappmenu.tmp
      echo "and give you more instructions." >>cliappmenu.tmp
      # Get the screen resolution or X-window size.
      # Get rows (height).
      Y=$(stty size | awk '{ print $1 }')
      let Y=$Y-3  # Make room at top of window for a backtitle.
      # Get columns (width).
      X=$(stty size | awk '{ print $2 }')
      #
      $GUI --backtitle "(use arrow keys and spacebar to scroll up/down/side-ways)" --title "HOW-TO Reinstall" --textbox cliappmenu.tmp $Y $X
      #
      if [ -r cliappmenu.tmp ] ; then
         rm cliappmenu.tmp
      fi
} # End of function f_reinstall_readme_gui
#
# +----------------------------------------+
# |      Function f_show_max_menu_items    |
# +----------------------------------------+
#
#  Inputs: $1=THIS_DIR, FCOLOR, BCOLOR, ECOLOR.
#    Uses: DELIMITER.
# Outputs: MAX, MOD_FILE, MENU_ITEM_MAX, MOD_FUNC.
#
# This function will scan all module files
# for all menus and count the number of items in each menu.
#
# This is a stand-alone function which is used to alert the programmer
# if the number of menu items is equal to or exceeding 15 menu items.
# The maximum number of menu items you can have is 16, to still fit on a
# standard 80x24 line display screen.
#
# HOW-TO use this function
# 1. Create a script file, "cli_app_menu_check.sh" in the same directory
#    as the mod_apps-*.lib module files with the following line:
#
#    . lib_cli-common.lib ; f_show_max_menu_items /home/robert/cli-app-menu
#
# 2. Then run the script by: "bash cli-app-menu_check.sh"
#
f_show_max_menu_items () {
      #
      # Calculate $MAX, the number of menu items using grep -c(ount) option.
      # Count number of lines containing special comment marker string to get
      # maximum item number.
      #
      # MENU_ITEM_MAX=16 is best for a standard 80x24 CLI screen.
      # MENU_ITEM_MAX may be changed for higher resolution screens beyond VGA 800x640.
      MENU_ITEM_MAX=16
      #
      # Set $DELIMITER to the Special Menu Item Marker.
      for DELIMITER in $(grep [#]:M[A-Z][A-Z] "$1/README" | awk '{print $1}')
      do
          grep "$DELIMITER" $1/README
          DELIMITER=${DELIMITER/:/} # Use string substitution.
          # Using sh (DASH) shell will cause "Bad substitution" error.
          #
          # Get name of module library file from the Application Category Menu
          # lib_cli-menu-cat.lib.
          # for-loop awk command uses back-ticks to execute resulting in name
          # of mod_apps-*.lib.
          for MOD_FUNC in `awk -F "#AAB" '{if ($2&&!$3){print $1}}' $1/lib_cli-menu-cat.lib | awk -F "#f_" '{print $2}'`
          do
              #
              # Convert the function name in the "Application Category Menu"
              # to a file name.
              #
              # The conversion is necessary because the file names may contain
              # <dash> characters while function names cannot under
              # non-bash shells (just trying to follow the naming convention).
              #
              MOD_FILE=$MOD_FUNC
              # Substitute <underscore> for <dash>.
              MOD_FILE=${MOD_FILE/mod_apps_/mod_apps-}
              # Substitution for audio-video.
              MOD_FILE=${MOD_FILE/audio_video/audio-video}
              # Substitution for screen-tools.
              MOD_FILE=${MOD_FILE/screen_tools/screen-tools}
              # Complete the <file name> change.
              MOD_FILE=$MOD_FILE.lib
              # Human readable list without special comment markers.
              # Indents one space before application name.
              #
              # Human readable list without special comment markers.
              # Indents one space before application name.
              # Is the module library file downloaded in $THIS_DIR?
              if [ -r $1/$MOD_FILE ] ; then  # $MOD_FILE already exists
                                                    # in current directory.
                 MAX=$(awk -F "$DELIMITER" '{if ($2&&!$3){print $0}}' $1/$MOD_FILE | grep -c "$DELIMITER")
                 #
                 if [ $MAX -ge $MENU_ITEM_MAX ] ; then # 16 items maximum in a menu.
                    # Use different color font for error messages.
                    f_term_color $ECOLOR $BCOLOR
                    echo -n $(tput bold)
                    #
                    echo ">>>>>>> WARNING! Number of menu items: $MAX <<<<<<<"
                    #
                    echo -n $(tput sgr0); f_term_color $FCOLOR $BCOLOR
                 # elif [ $MAX -gt 0 ] ; then
                 #    echo "        MAX=$MAX"
                 fi
              fi
           #
          done
      done
      unset DELIMITER  # Throw out this variable.
} # End of function f_show_max_menu_items
