# Â©2019 Copyright 2019 Robert D. Chin
#
# +----------------------------------------+
# |             Revision Date              |
# +----------------------------------------+
# REVDATE="February-10-2016 23:59"
#
# +----------------------------------------+
# |       Function f_menu_cat_system       |
# +----------------------------------------+
#
#  Inputs: $GUI.
#    Uses: None.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_cat_system () {
      case $GUI in
           dialog | whiptail)
           f_menu_cat_system_gui
           ;;
           text)
           f_menu_cat_system_txt
           ;;
      esac
} # End of function f_menu_cat_system
#
# +----------------------------------------+
# |      Function f_menu_cat_system_txt    |
# +----------------------------------------+
#
#  Inputs: None.
#    Uses: BSY, MENU_ITEM, MAX
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_cat_system_txt () {
      f_initvars_menu_app "BSY"
      until [ "$BSY" = "0" ]
      do    # Start of System Application Category until loop.
#f_menu_app_sys_backup      #BSY Backup      - File Backup.
#f_menu_app_sys_disks       #BSY Disks       - Disk information.
#f_menu_app_sys_health      #BSY Health      - Anti-virus scanners, root-kit detectors, stress tests etc.
#f_menu_app_sys_linux       #BSY Linux       - Linux information and configuration; kernel configuration.
#f_menu_app_sys_logs        #BSY Logs        - Log file viewers, command line history, send mssg. to users.
#f_menu_app_sys_mainboard   #BSY Mainboard   - Information on PC mainboard, memory, etc.
#f_menu_app_sys_monitors    #BSY Monitors    - Resources, and disk I/O monitors.
#f_menu_app_sys_peripherals #BSY Peripherals - Information on PC peripherals, PCI devices, hard drives, etc.
#f_menu_app_sys_process     #BSY Process     - System process monitoring, killing.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Categories Menu"
            DELIMITER="#BSY" #BSY This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read BSY
            f_menu_item_process $BSY  # Outputs $MENU_ITEM.
      done  # End of System Application Category until loop.
            #
      unset BSY MENU_ITEM  # Throw out this variable.
} # End of function f_menu_cat_system_txt
#
# +----------------------------------------+
# |     Function f_menu_cat_system_gui     |
# +----------------------------------------+
#
#  Inputs: GUI.
#    Uses: BSY, MENU_TITLE, THIS_FILE.
# Outputs: None.
#
f_menu_cat_system_gui () {
      f_initvars_menu_app "BSY"
      until [ "$BSY" = "0" ]
      do    # Start of System Application Category until loop.
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Categories Menu"
            BSY=$($GUI --title "$MENU_TITLE" --menu "\n\nUse (up/down arrow keys) or (letters):" 20 80 11 \
            "Return"        "Return to previous menu." \
              "Backup"      "File Backup." \
              "Disks"       "Disk information." \
              "Health"      "Anti-virus scanners, root-kit detectors, stress tests etc." \
              "Linux"       "Linux information and configuration; kernel configuration." \
              "Logs"        "Log file viewers, command line history, send mssg. to users." \
              "Mainboard"   "Information on PC mainboard, memory, etc." \
              "Monitors"    "Resources, and disk I/O monitors." \
              "Peripherals" "Information on PC peripherals, PCI devices, hard drives, etc." \
              "Process"     "System process monitoring, killing." \
            2>&1 >/dev/tty)
             #
            case $BSY in
                 "Return") BSY=0 ;;
                 "Backup") f_menu_app_sys_backup ;;
                 "Disks") f_menu_app_sys_disks ;;
                 "Health") f_menu_app_sys_health ;;
                 "Logs") f_menu_app_sys_logs ;;
                 "Mainboard") f_menu_app_sys_mainboard ;;
                 "Monitors") f_menu_app_sys_monitors ;;
                 "Linux") f_menu_app_sys_linux ;;
                 "Peripherals") f_menu_app_sys_peripherals ;;
                 "Process") f_menu_app_sys_process ;;
            esac
            #
      done  # End of System Application Category until loop.
            #
      unset BSY THIS_FILE MENU_TITLE  # Throw out this variable.
} # End of function f_menu_cat_system_gui
#
# +----------------------------------------+
# |     Function f_menu_app_sys_backup     |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSB, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_backup () {
      f_initvars_menu_app "MSB"
      until [ "$MSB" = "0" ]
      do    # Start of Backup Applications until loop.
#0^0^0^0^1 #MSB dtrx  - Use tar without remembering which flags for each file to use.
#0^0^0^0^1 #MSB rsync - File backup, mirror, directories and files.
#0^0^0^0^1 #MSB tar   - File backup, compress files.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="Backup/Archive Applications Menu"
            DELIMITER="#MSB" #MSB This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSB
            f_menu_item_process $MSB  # Outputs $MENU_ITEM.
      done  # End of Backup Applications until loop.
            #
      unset MSB MENU_ITEM  # Throw out this variable.
} # End of function f_menu_app_sys_backup
#
# +----------------------------------------+
# |      Function f_menu_app_sys_disks     |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSD, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_disks () {
      f_initvars_menu_app "MSD"
      until [ "$MSD" = "0" ]
      do    # Start of System Disks Information Applications until loop.
#0^0^0^0^1 #MSD agedu     - Find wasted disk space.
#0^0^0^0^1 #MSD badblocks - Scans disks for bad sectors.
#0^0^0^0^1 #MSD blkid     - Block devices information.
#0^0^0^0^1 #MSD cdf       - df-like also shows capacity of mount-points.
#0^0^0^1^0 #MSD cfdisk    - Disk partition tool.
#0^0^0^0^1 #MSD ddir      - Tree-view of disk space utilization.
#1^0^0^0^1 #MSD df        - Disk usage and mount points, usage: 'df -hT'.
#0^0^0^0^1 #MSD dfc       - Disk usage and mount points, graphical display.
#0^0^0^0^1 #MSD di        - df-like disk usage utility.
#0^0^0^0^1 #MSD discus    - df-like disk usage utility with color, graphs, formatting.
#1^0^0^0^1 #MSD du        - Disk usage monitor by directory.
#0^0^0^0^1 #MSD dumpe2fs  - Displays superblock and block information of a device.
#0^0^0^0^1 #MSD eject     - Ejects media, CD, DVD, floppy disks, SCSI drives, tape drives.
#0^0^0^1^0 #MSD gt5       - A diff-capable du-browser.
#0^0^0^0^1 #MSD hdparm    - Show/set disk parameters, settings. 
#f_menu_app_sys_disks2^0^0^0^1 #MSD MORE...   - For more system disk information applications.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Disks Information Menu"
            DELIMITER="#MSD" #MSD This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER"
            read MSD
            f_menu_item_process $MSD  # Outputs $MENU_ITEM.
      done  # End of System Disks Information Applications until loop.
            #
      unset MSD MENU_ITEM  # Throw out this variable.
} # End of function f_menu_app_sys_disks
#
# +----------------------------------------+
# |      Function f_menu_app_sys_disks2    |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSD, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_disks2 () {
      f_initvars_menu_app "MSE"
      until [ "$MSE" = "0" ]
      do    # Start of System Disks Information Applications until loop.
#0^0^0^0^1 #MSE lsblk  - List block devices (disks).
#0^0^0^1^0 #MSE ncdu   - Disk usage monitor, ncurses-based.
#0^0^0^1^0 #MSE parted - Disk partition tool.
#1^0^0^0^1 #MSE pydf   - Disk usage df clone written in python.
#0^0^0^1^0 #MSE sfdisk - Partition table manipulator for Linux.
#0^0^0^0^1 #MSE tdu    - Tree-view of disk space utilization; ncurses-based.
#0^0^0^0^1 #MSE tree   - Tree-view of disk space utilization.
#1^0^0^0^1 #MSE uuid   - Use ls -l to show disk uuid number.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Disks Information2 Menu"
            DELIMITER="#MSE" #MSE This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER"
            read MSE
            f_menu_item_process $MSE  # Outputs $MENU_ITEM.
      done  # End of System Disks Information Applications until loop.
            #
      unset MSE MENU_ITEM  # Throw out this variable.
} # End of function f_menu_app_sys_disks2
#
# +----------------------------------------+
# |     Function f_menu_app_sys_health     |
# +----------------------------------------+
#
#  Inputs: None.
#    Uses: MSH, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_health () {
      f_initvars_menu_app "MSH"
      until [ "$MSH" = "0" ]
      do    # Start of System Health Applications until loop.
#0^0^0^0^1 #MSH aide       - Advanced Intrusion Detection Environment check file integrity.
#1^0^0^0^1 #MSH arp-scan   - Discover, fingerprint hosts on LAN using MAC addresses.
#0^0^0^0^1 #MSH arpalert   - Checks MAC addresses against list of known MACs, runs script.
#0^0^0^0^1 #MSH arpon      - ArpON detects/blocks arp poisoning/spoofing attacks.
#1^0^0^0^1 #MSH arpwatch   - Detects unknown MAC addresses and IP addresses, like ArpON.
#0^0^0^0^1 #MSH chkrootkit - Root Kit detector.
#1^0^0^0^1 #MSH clamscan   - Clam anti-virus program scans for viruses.
#0^0^0^0^1 #MSH cpuburn    - Stress test puts heavy loads on a CPU.
#0^0^0^1^1 #MSH freshclam  - Clam anti-virus database definition update.
#1^0^0^0^1 #MSH hpcc       - HPC Challenge benchmark. 7 tests of CPU, memory and network.
#0^0^0^0^1 #MSH labrea     - Sticky honeypot entraps intruder tying up his CPU.
#0^0^0^0^1 #MSH lynis      - security auditing tool that tests for security holes in a PC.
#0^0^0^0^1 #MSH rkhunter   - Root Kit detector.
#0^0^0^0^1 #MSH siege      - Web site http regression and stress test, benchmarking.
#1^0^0^0^1 #MSH smb-nat    - Netbios audit servers running NetBIOS file sharing services.
#f_menu_app_sys_health2^0^0^0^1 #MSH MORE...    - More applications.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Health Applications Menu"
            DELIMITER="#MSH" #MSH This 3rd field prevents awk from printing this line into menu options.
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER"
            read MSH
            f_menu_item_process $MSH  # Outputs $MENU_ITEM.
      done  # End of System Health Applications until loop.
            #
      unset MSH MENU_ITEM  # Throw out this variable.
} # End of function f_menu_app_sys_health
#
# +----------------------------------------+
# |     Function f_menu_app_sys_health2    |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSJ, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_health2 () {
      f_initvars_menu_app "MSJ"
      until [ "$MSJ" = "0" ]
      do    # Start of System Health Applications until loop.
#1^0^0^0^1 #MSJ stress   - Stress test can simulate a heavy load on CPU.
#1^0^0^0^1 #MSJ tripwire - Detects/Reports changes in system files.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Health2 Applications Menu"
            DELIMITER="#MSJ" #MSJ This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSJ
            f_menu_item_process $MSJ  # Outputs $MENU_ITEM.
      done  # End of System Health Applications until loop.
            #
      unset MSJ MENU_ITEM  # Throw out this variable.
} # End of function f_menu_app_sys_health2
#
# +----------------------------------------+
# |      Function f_menu_app_sys_logs      |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MLO, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_logs () {
      f_initvars_menu_app "MLO"
      until [ "$MLO" = "0" ]
      do    # Start of System Logs until loop.
#0^0^0^0^1 #MLO ccze       - A robust and modular log colorizer, with plug-ins.
#0^0^0^0^1 #MLO colortail  - Log colorizer.
#0^0^0^0^1 #MLO hash       - Show frequency of commands entered at the prompt.
#1^0^0^0^1 #MLO history    - Show history of commands entered at the prompt.
#0^0^0^0^1 #MLO inotail    - Tail command replacement uses the inotify API to re-read files.
#1^0^0^0^1 #MLO last       - Users' login/logout times from /var/log/wtmp.
#0^0^0^0^1 #MLO lastb      - Lists bad login attempts.
#0^0^0^0^1 #MLO lastlog    - Users' login/logout times from /var/log/wtmp.
#0^0^0^0^1 #MLO lnav       - View, analyze log files, histogram, hotkeys, ncurses-based.
#0^0^0^0^1 #MLO logtailer  - Monitor logs for updates and display them.
#0^0^0^0^1 #MLO monkeytail - tail variant designed for web developers monitoring log files.
#0^0^0^0^1 #MLO multitail  - View multiple log files using multiple panes.
#0^0^0^0^1 #MLO since      - Shows new changes in log files since last run. Tail-like.
#0^0^0^0^1 #MLO swatch     - Log file viewer with regexp matching, highlighting & hooks.
#1^0^0^0^1 #MLO wall       - Send a message to logged in users.
#0^0^0^0^1 #MLO wuzzah     - Users' login/logout events from utmpx records.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Logs Menu"
            DELIMITER="#MLO" #MLO This 3rd field prevents awk from printing this line into menu options.
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MLO
            f_menu_item_process $MLO  # Outputs $MENU_ITEM.
      done  # End of System Logs Applications until loop.
            #
      unset MLO MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_sys_logs
#
# +----------------------------------------+
# |   Function f_menu_app_sys_mainboard    |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSI, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_mainboard () {
      f_initvars_menu_app "MSI"
      until [ "$MSI" = "0" ]
      do    # Start of System Information until loop.
#0^0^0^0^1 #MSI dmidecode     - Main board information.
#0^0^0^0^1 #MSI dnsdomainname - Show the system's DNS domain name
#0^0^0^0^1 #MSI domainname    - Show or set the system's NIS/YP domain name
#1^0^0^0^1 #MSI free          - Memory usage RAM and swap.
#1^0^0^0^1 #MSI hdparm        - Hard disk drive information.
#0^0^0^0^1 #MSI hostname      - Show or set the system's host name
#1^0^0^0^1 #MSI lsb_release   - Linux distro and LSB (Linux Standard Base).
#0^0^0^0^1 #MSI lscpu         - CPU information.
#1^0^0^0^1 #MSI lshw          - Main board information.
#0^0^0^0^1 #MSI mbw           - "Copy" memory bandwidth available to userspace programs.
#0^0^0^0^1 #MSI nisdomainname - Show or set the system's NIS/YP domain name
#1^0^0^1^0 #MSI slabtop       - Kernel slab cache information in real time.
#0^0^0^0^1 #MSI vmstat        - Memory usage RAM and swap, CPU information.
#0^0^0^0^1 #MSI ypdomainname  - Show or set the system's NIS/YP domain name
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="Mainboard Information Menu"
            DELIMITER="#MSI" #MSI This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSI
            f_menu_item_process $MSI  # Outputs $MENU_ITEM.
      done  # End of Mainboard System Information Applications until loop.
            #
      unset MSI MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_sys_mainboard
#
# +----------------------------------------+
# |     Function f_menu_app_sys_linux      |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSL, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_linux () {
      f_initvars_menu_app "MSL"
      until [ "$MSL" = "0" ]
      do    # Start of System Linux Kernel until loop.
#1^0^0^0^1 #MSL ctrlaltdel  - Set the function of the Ctrl-Alt-Del combination.
#1^0^0^0^1 #MSL insmod      - Insert a module into the Linux Kernel.
#1^0^0^0^1 #MSL lsb_release - Linux distro and LSB (Linux Standard Base).
#0^0^0^0^1 #MSL lsmod       - Linux kernel module information.
#1^0^0^0^1 #MSL modinfo     - Show information about a Linux Kernel module.
#0^0^0^0^1 #MSL modprobe    - Add and remove modules from the Linux Kernel.
#1^0^0^0^1 #MSL rmmod       - Remove a module from the Linux Kernel.
#1^0^0^1^0 #MSL slabtop     - Kernel slab cache information in real time.
#1^0^0^0^1 #MSL uname       - Linux kernel information.
#0^0^0^0^1 #MSL which       - Show the pathnames of commands, applications, and files.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="Linux Kernel Application Menu"
            DELIMITER="#MSL" #MSL This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSL
            f_menu_item_process $MSL  # Outputs $MENU_ITEM.
      done  # End of Mainboard System Linux Kernel Applications until loop.
            #
      unset MSL MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_sys_linux
#
# +----------------------------------------+
# |    Function f_menu_app_sys_monitors    |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSM, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_monitors () {
      f_initvars_menu_app "MSM"
      until [ "$MSM" = "0" ]
      do    # Start of System Monitors until loop.
#0^0^0^0^1 #MSM acpi      - Show acpi information.
#0^0^0^0^0 #MSM acpitail  - Show acpi information in growing tail list.
#0^0^0^0^1 #MSM atsar     - CPU, network, memory & disk I/O, record data for analysis.
#1^0^0^0^1 #MSM cacti     - Front-end to rrdtool for monitoring systems and services.
#1^0^0^0^1 #MSM chkconfig - System update/query run-level processes at boot time.
#0^0^0^1^0 #MSM collectl  - All-in-One Performance Monitoring Tool.
#0^0^0^1^0 #MSM conky-cli - Versatile, configurable system monitor.
#1^0^0^0^1 #MSM dstat     - View system resources, replaces vmstat, iostat, ifstat.
#0^0^0^1^0 #MSM glances   - View system processes/resources, CPU/Load/Mem/Swap/Disk/BW.
#0^0^0^0^1 #MSM id        - Print user and group names and information.
#0^0^0^0^1 #MSM iostat    - CPU usage and disk I/O process monitor.
#0^0^0^1^0 #MSM iotop     - Disk I/O process monitor.
#0^0^0^1^0 #MSM locale    - Get locale specific information.
#1^0^0^0^1 #MSM mpstat    - CPU microprocessor usage monitor.
#0^0^0^0^0 #MSM nmon      - CPU usage, memory, network, disk usage, processes, resources.
#f_menu_app_sys_monitors2^0^0^0^1 #MSM MORE...   - For more system monitor applications.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Monitors Menu"
            DELIMITER="#MSM" #MSM This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSM
            f_menu_item_process $MSM  # Outputs $MENU_ITEM.
      done  # End of System Monitors Applications until loop.
            #
      unset MSM MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_sys_monitors
#
# +----------------------------------------+
# |    Function f_menu_app_sys_monitors2   |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSN, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_monitors2 () {
      f_initvars_menu_app "MSN"
      until [ "$MSN" = "0" ]
      do    # Start of System Monitors until loop.
#0^0^0^0^0 #MSN rcconf       - Enable/disable startup scripts/services; ncurses-based.
#0^0^0^0^0 #MSN ntsysd       - RedHat view/enable/disable startup scripts/services.
#0^0^0^0^1 #MSN rrdtool      - Round Robin Database Tool stores/displays time-series data.
#0^0^0^1^0 #MSN saidar       - Monitor system processes, network I/O, disks I/O, free space.
#0^0^0^0^1 #MSN sar          - CPU usage statistics, user/nice/system/iowait/steal/idle.
#0^0^0^0^1 #MSN smem         - Show memory usage for current user, per user, all users.
#0^0^0^0^1 #MSN sysstat      - All-in-one performance monitoring tool.
#0^0^0^1^0 #MSN sysv-rc-conf - Enable/disable startup scripts/services; ncurses-based.
#f_run_and_exit "tload" "tload"^0^0^0^1 #MSN tload        - System load average graphical monitor.
#f_run_and_exit "ttyload" "ttyload"^0^0^8^1 #MSN ttyload      - Color-coded graphs of CPU load average.
#0^0^0^1^0 #MSN yacpi        - ACPI monitor, ncurses-based.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Monitors2 Menu"
            DELIMITER="#MSN" #MSN This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSN
            f_menu_item_process $MSN  # Outputs $MENU_ITEM.
      done  # End of System Monitors Applications until loop.
            #
      unset MSN MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_sys_monitors2
#
# +----------------------------------------+
# |   Function f_menu_app_sys_peripherals  |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSV, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_peripherals () {
      f_initvars_menu_app "MSV"
      until [ "$MSV" = "0" ]
      do    # Start of Peripheral System Information until loop.
#0^0^0^0^1 #MSV acpitool  - ACPI power/battery settings.
#1^0^0^0^1 #MSV blkid     - Block devices information.
#0^0^0^0^1 #MSV cdde      - Detects if a CD is inserted, runs specified program.
#0^0^0^0^1 #MSV colortest - Test color capabilities of a terminal.
#0^0^0^0^1 #MSV findfs    - Find a filesystem by label or UUID.
#0^0^0^0^1 #MSV gitkeys   - Displays the key sequence sent by the pressed key.
#0^0^0^0^1 #MSV inxi      - Show model/make, CPU, graphics, audio, network, HDD, etc.
#0^0^0^0^1 #MSV kbd       - Control keyboard LEDs, repeat/delay rates, keymaps, etc.
#0^0^0^0^1 #MSV loadkeys  - Load keyboard translation tables
#0^0^0^0^1 #MSV lsblk     - List block devices (disks).
#0^0^0^0^1 #MSV lsof      - Display information about open files.
#1^0^0^0^1 #MSV lspci     - PCI buses and connected devices.
#1^0^0^0^1 #MSV lspcmcia  - PCMCIA extended debugging information.
#0^0^0^0^1 #MSV lsusb     - USB devices.
#0^0^0^0^1 #MSV mzip      - Change protection mode and eject disk on Zip/Jaz drive.
#f_menu_app_sys_peripherals2^0^0^0^1 #MSV MORE...   - For more peripheral system applications.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="Peripheral System Information Menu"
            DELIMITER="#MSV" #MSV This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSV
            f_menu_item_process $MSV  # Outputs $MENU_ITEM.
      done  # End of Peripheral System Information Applications until loop.
            #
      unset MSV MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_sys_peripherals
#
# +----------------------------------------+
# |   Function f_menu_app_sys_peripherals2 |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSW, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_peripherals2 () {
      f_initvars_menu_app "MSW"
      until [ "$MSW" = "0" ]
      do    # Start of Peripheral System Information2 until loop.
#1^0^0^0^1 #MSW pccardctl - PCMCIA card devices.
#0^0^0^0^1 #MSW printenv  - Environmental variables.
#0^0^0^0^1 #MSW scanimage - Control flatbed scanners, cameras. -L list of devices.
#0^0^0^0^1 #MSW setcd     - Control CDROM device, auto-close/eject/locking, set speed.
#0^0^0^0^1 #MSW uptime    - Display how long PC has been running, # users, load average.
#0^0^0^0^1 #MSW w         - A combination of uptime and who commands.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="Peripheral System Information2 Menu"
            DELIMITER="#MSW" #MSW This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSW
            f_menu_item_process $MSW  # Outputs $MENU_ITEM.
      done  # End of Peripheral System Information2 Applications until loop.
            #
      unset MSW MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_sys_peripherals2
#
# +----------------------------------------+
# |     Function f_menu_app_sys_process    |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSQ, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_process () {
      f_initvars_menu_app "MSQ"
      until [ "$MSQ" = "0" ]
      do    # Start of System Process Applications until loop.
#0^0^0^1^0 #MSQ acct      - Switch process accounting on/off.
#0^0^0^1^0 #MSQ atop      - View system processes/resources, CPU/Mem/Swap/Page/Disk/Net.
#0^0^0^0^1 #MSQ fuser     - Identify processes using files or sockets.
#0^0^0^0^1 #MSQ gitps     - Interactive process viewer/killer.
#0^0^0^3^0 #MSQ htop      - View system processes/resources; bar graph of CPU/Mem/Swap.
#0^0^0^0^1 #MSQ ips       - "Intelligent process status" with easy tracking of processes.
#0^0^0^0^1 #MSQ killall   - Kill processes based on full-name of process.
#0^0^0^0^1 #MSQ pgrep     - Search ps output for full/partial name of process.
#1^0^0^0^1 #MSQ pidstat   - View system processes/resources, PID/USR/System/Guest/CPU/Cmd.
#0^0^0^0^1 #MSQ pkill     - Kill processes based on partial name of process.
#0^0^0^0^1 #MSQ pmap      - View process memory usage.
#0^0^0^0^1 #MSQ powertop  - Find software components which consume the most power.
#0^0^0^0^1 #MSQ ps        - View system processes/resources, PID/PGID/SID/TTY/Time/Cmd.
#0^0^0^0^1 #MSQ pstree    - Tree view system processes/resources, like "ps" command.
#0^0^0^0^1 #MSQ pswatcher - Execute commands when certain processes are run.
#f_menu_app_sys_process2^0^0^0^1 #MSQ MORE...   - For more system process applications.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Process Applications Menu"
            DELIMITER="#MSQ" #MSQ This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSQ
            f_menu_item_process $MSQ  # Outputs $MENU_ITEM.
      done  # End of System Process Applications until loop.
            #
      unset MSQ MENU_ITEM  # Throw out this variable.
} # End of function f_menu_app_sys_process
#
# +----------------------------------------+
# |     Function f_menu_app_sys_process2   |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSR, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_process2 () {
      f_initvars_menu_app "MSR"
      until [ "$MSR" = "0" ]
      do    # Start of System Process Applications until loop.
#0^0^0^0^1 #MSR pwdx   - Report current working directory of a process.
#0^0^0^0^1 #MSR strace - Trace process system calls and signals.
#0^0^0^0^1 #MSR sysctl - Configure kernel parameters at runtime.
#0^0^0^1^0 #MSR top    - View system PID/User/PR/NI/VERT/RES/SHR/CPU/MEM/Time/Cmd.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Process2 Applications Menu"
            DELIMITER="#MSR" #MSR This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSR
            f_menu_item_process $MSR  # Outputs $MENU_ITEM.
      done  # End of System Process2 Applications until loop.
            #
      unset MSR MENU_ITEM  # Throw out this variable.
} # End of function f_menu_app_sys_process2
#
# +----------------------------------------+
# |           Function f_arp-scan          |
# +----------------------------------------+
#
f_arp-scan () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "arp-scan - ARP Scanner."
         echo
         echo "Usage:"
         echo "arp-scan [OPTIONS] [HOSTS]..."
         echo
         echo "       --localnet or -l"
         echo "              Generate addresses from network  interface  configuration.   Use"
         echo "              the  network  interface  IP address and network mask to generate"
         echo "              the list of target host addresses.  The list  will  include  the"
         echo "              network  and  broadcast  addresses,  so  an interface address of"
         echo "              10.0.0.1 with netmask 255.255.255.0 would  generate  256  target"
         echo "              hosts  from  10.0.0.0  to 10.0.0.255 inclusive."
         echo
         echo "       --interface=<s> or -I <s>"
         echo "              Use  network  interface  <s>."
         echo
         echo "Now run arp-scan on this PC as an example."
         echo "Usage: arp-scan -I <interface>"
         echo
         f_press_enter_key_to_continue
         f_find_NIC
         APP_NAME="arp-scan -I $ANS"
      fi
} # End of function f_arp-scan
#
# +----------------------------------------+
# |           Function f_arpwatch          |
# +----------------------------------------+
#
f_arpwatch () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "arpwatch - Keep track of ethernet/ip address pairings"
         echo
         echo "Arpwatch  keeps  track  for  ethernet/ip  address  pairings. It syslogs"
         echo "activity and reports certain changes via email.  Arpwatch uses  pcap(3)"
         echo "to listen for arp packets on a local ethernet interface."
         echo
         echo "Usage:"
         echo "arpwatch [-dN] [-f datafile] [-i interface] [-n net[/width]] [-r file]"
         echo "         [-s sendmail_path] [-p] [-a] [-m addr] [-u username]"
         echo "         [-R seconds ] [-Q] [-z ignorenet/ignoremask]"
         echo
         echo "Now run man arpwatch. Usage: man arpwatch"
         echo
         APP_NAME="man arpwatch"
         f_press_enter_key_to_continue
      fi
} # End of function f_arpwatch
#
# +----------------------------------------+
# |             Function f_blkid           |
# +----------------------------------------+
#
f_blkid () {
      clear # Blank the screen.
      echo "blkid - Locate/print block device attributes"
      echo
      echo "The blkid program is the command-line interface to working with the libblkid(3)"
      echo "library.  It can determine the type of content (e.g. filesystem or swap) that a"
      echo "block device holds, and also attributes (tokens, NAME=value pairs) from the"
      echo "content metadata (e.g. LABEL or UUID fields)."
      echo
      echo "blkid has two main forms of operation: either searching for a device with a"
      echo "specific NAME=value pair, or displaying NAME=value pairs  for  one  or more"
      echo "specified devices."
      echo
      echo "Usage:"
      echo "blkid -L label | -U uuid"
      echo "blkid [-dghlv] [-c file] [-w file] [-o format] [-s tag] [-t NAME=value][device]"
      echo "blkid -p [-O offset] [-S size] [-o format] [-s tag] [-n list] [-u list] device"
      echo "blkid -i [-o format] [-s tag] device ..."
      echo
      echo "*** For more help type: 'man blkid'"
      echo "                        'blkid --help'"
      echo
      f_press_enter_key_to_continue
} # End of f_blkid
#
# +----------------------------------------+
# |             Function f_cacti           |
# +----------------------------------------+
#
f_cacti () {
      clear # Blank the screen.
      echo "cacti - Frontend to rrdtool for monitoring systems and services."
      echo
      echo "Cacti is a complete front-end to rrdtool, it stores all of the necessary"
      echo "information to create graphs and populates them with data in a MySQL"
      echo "database.  The front-end is completely PHP driven.  Along with being able"
      echo "to maintain Graphs, Data Sources, and Round Robin Archives in a"
      echo "database, cacti handles the data gathering also.  There is also SNMP"
      echo "support for those used to creating traffic graphs with MRTG."
      echo
      echo "This package requires a functional MySQL database server on either the"
      echo "installation host or remotely accessible system.  If you do not already"
      echo "have a database server available, you should also install mysql-server."
      echo
      echo "Homepage: http://www.cacti.net/"
      echo
      echo "*** For more help type: 'man cacti'"
      echo "                        'cacti --help'"
      echo
      APP_NAME="cacti"
      f_press_enter_key_to_continue
} # End of f_cacti
#
# +----------------------------------------+
# |           Function f_chkconfig         |
# +----------------------------------------+
#
f_chkconfig () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "chkconfig - Manipulate run-level services at boot time."
         echo
         echo "Usage:"
         echo "chkconfig -t|--terse [names]"
         echo "chkconfig -s|--set [name state]"
         echo "chkconfig -e|--edit [names]"
         echo "chkconfig -c|--check name [state]"
         echo "chkconfig -l|--list [--deps] [names]"
         echo "chkconfig -A|--allservices"
         echo "chkconfig -a|--add [names]"
         echo "chkconfig -d|--del [names]"
         echo
         echo "*** For more help type: 'man chkconfig'"
         echo "                        'chkconfig --help'"
         echo
         echo "Now run chkconfig. Usage: chkconfig -l"
         APP_NAME="chkconfig -l"
         f_press_enter_key_to_continue
      fi
} # End of f_chkconfig
#
# +----------------------------------------+
# |           Function f_clamscan          |
# +----------------------------------------+
#
f_clamscan () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "clamscan -  Anti-virus scanner"
         echo
         echo "Usage:" 
         echo "clamscan [OPTIONS] [FILE/DIRECTORY/-]"
         echo "         --recursive -r  will recursively scan a directory."
         echo "         --verbose   -v  be verbose."
         echo "         --infected  -i  only print infected files."
         echo "         --bell          sound bell on virus detection."
         echo
         echo "*** For more help type: 'man clamscan'"
         echo "                        'clamscan --help'"
         echo
         echo "Clam anti-virus will now scan the folder, please be patient"
         echo "since Clam anti-virus is slow to scan, but thorough."
         echo
         echo "Now run clamscan. Usage: clamscan -r ~"
         echo
         APP_NAME="clamscan -r ~"
         f_press_enter_key_to_continue
      fi
} # End of function f_clamscan
#
# +----------------------------------------+
# |              Function f_df             |
# +----------------------------------------+
#
f_df () {
      clear # Blank the screen.
      echo "df - Displays free space on disk"
      echo
      echo "Usage:"
      echo "df [OPTION]... [FILE]..."
      echo "df [OPTION]... --files0-from=F"
      echo "   -h, --human-readable    format (e.g., 1K 234M 2G)"
      echo "   --total                 produce a grand total"
      echo "   -t, --type=TYPE         limit listing to specific file systems"
      echo "   -T, --print-type        print file system type"
      echo "   -x, --exclude-type=TYPE limit listing to file systems not of type TYPE"
      echo
      echo "*** For more help type: 'man df'"
      echo "                        'df --help'"
      echo
      echo "Display total disk usage in human-readable format."
      echo
      echo "Now run du. Usage: df -hT"
      APP_NAME="df -hT"
      f_press_enter_key_to_continue
} # End of function f_df
#
# +----------------------------------------+
# |             Function f_dstat           |
# +----------------------------------------+
#
f_dstat () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "dstat - Display system resource statistics."
         echo
         echo "Usage:"
         echo "dstat [-afv] [OPTIONS..] [DELAY [COUNT]]"
         echo
         echo "*** For more help type: 'man dstat'"
         echo "                        'dstat --help'"
         echo
         echo "dstat this PC (localhost) for 10 times as an example."
         echo
         echo "Now run dstat. Usage: dstat 1 10"
         APP_NAME="dstat 1 10"
         f_press_enter_key_to_continue
      fi
} # End of f_dstat
#
# +----------------------------------------+
# |              Function f_du             |
# +----------------------------------------+
#
f_du () {
      clear # Blank the screen.
      echo "du - Displays disk usage per directory"
      echo
      echo "Usage:"
      echo "du [OPTION]... [FILE]..."
      echo "du [OPTION]... --files0-from=F"
      echo "   -h, --human-readable  human-readable format (e.g., 1K 234M 2G)"
      echo "   -c, --total           produce a grand total"
      echo "   -S, --separate-dirs   do not include sub-folders"
      echo "   -s, --summarize       display only a total"
      echo "   --exclude=PATTERN     exclude files matching PATTERN"
      echo "   -d, --max-depth=N     N  or  fewer  levels  below"
      echo
      echo "*** For more help type: 'man du'"
      echo "                        'du --help'"
      echo
      echo "Display total disk usage in human-readable format."
      echo
      echo "Now run du. Usage: du -hsc"
      APP_NAME="du -hsc"
      f_press_enter_key_to_continue
} # End of function f_du
#
# +----------------------------------------+
# |             Function f_free            |
# +----------------------------------------+
#
f_free () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "free - Display the amount of free and used memory both RAM and swap"
         echo
         echo "Usage:"
         echo "free [-b|-k|-m|-g] [-c count] [-l] [-o] [-t] [-s delay] [-V]"
         echo
         echo "*** For more help type: 'man free'"
         echo "                        'free --help'"
         echo
         echo "Display in MB Megabytes with column totals, for 5 times every 2 seconds."
         echo
         echo "Now run free. Usage: free -m -t -s 2 -c 5"
         APP_NAME="free -m -t -s 2 -c 5"
         f_press_enter_key_to_continue
      fi
} # End of f_free
#
# +----------------------------------------+
# |            Function f_hdparm           |
# +----------------------------------------+
#
f_hdparm () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "hdparm - Get SATA/IDE hard disk drive parameters."
         echo
         echo "Usage:"
         echo "hdparm [OPTIONS..] [DEVICE ...]"
         echo
         echo "*** For more help type: 'man hdparm'"
         echo "                        'hdparm --help'"
         echo
         echo "Find information about the first hard disk drive: /dev/sda on this PC (localhost)."
         echo
         echo "Now run hdparm. Usage: 'hdparm -I /dev/sda'"
         APP_NAME="hdparm -I /dev/sda"
         f_press_enter_key_to_continue
      fi
} # End of f_hdparm
#
# +----------------------------------------+
# |            Function f_history          |
# +----------------------------------------+
#
f_history () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "history - List of previous user-input usually commands typed in from keyboard."
         echo 
         echo "Event Designators"
         echo "An event designator is a reference to a command line entry in the  hisâ"
         echo "tory  list.   Unless  the reference is absolute, events are relative to"
         echo "the current position in the history list."
         echo
         echo "!      Start a history substitution, except when followed by  a  blank,"
         echo "     newline, = or (."
         echo "!n     Refer to command line n."
         echo "!-n    Refer to the current command minus n."
         echo "!!     Refer to the previous command.  This is a synonym for \`!-1\'."
         echo "!string"
         echo "       Refer  to the most recent command preceding the current position"
         echo "       in the history list starting with string."
         echo "!?string[?]"
         echo "       Refer to the most recent command preceding the current  position"
         echo "       in  the  history  list containing string.  The trailing ? may be"
         echo "       omitted if string is followed immediately by a newline."
         f_press_enter_key_to_continue
         clear # Blank the screen.
         echo "^string1^string2^"
         echo "       Quick substitution.  Repeat the last command, replacing  string1"
         echo "       with string2.  Equivalent to ``!!:s/string1/string2/'' (see Modâ"
         echo "       ifiers below)."
         echo "!#     The entire command line typed so far."
         echo 
         echo "*** For more help type: 'man history'"
         echo "                'history --help'"
         echo
         echo "Now run history. Usage: 'history"
         APP_NAME="history"
         f_press_enter_key_to_continue
      fi
} # End of f_history
#
# +----------------------------------------+
# |             Function f_hpcc            |
# +----------------------------------------+
#
f_hpcc () {
      clear # Blank the screen.
      echo "hpcc -  HPC Challenge benchmark"
      echo
      echo "The High Performance Computing (HPC) Challenge benchmark runs a suite"
      echo "of 7 tests that measure the performance of CPU, memory and network for"
      echo "HPC clusters.  Amongst others, it includes the High-Performance LINPACK"
      echo "(HPL) benchmark, used by the Top500 ranking (http://www.top500.org/)."
      echo
      f_press_enter_key_to_continue
} # End of function f_hpcc
#
# +----------------------------------------+
# |             Function f_last            |
# +----------------------------------------+
#
f_last () {
      clear # Blank the screen.
      echo "last - Lists all users logged in/out with timestamps"
      echo
      echo "It searches the file /var/log/wtmp (or the file designated"
      echo "by the -f flag) and displays a list of all users logged in/out"
      echo "with the user name, device, ip address, date stamp, duration."
      echo
      echo "Examples:"
      echo "Show last times PC was rebooted."
      echo "last reboot -F"
      echo
      echo "Show login/out times for user 'guest'."
      echo "last guest"
      echo "last guest -i"
      echo
      echo "Related command: lastb"
      echo "Show failed login attempts."
      f_press_enter_key_to_continue
} # End of function f_last
#
# +----------------------------------------+
# |          Function f_lsb_release        |
# +----------------------------------------+
#
f_lsb_release () {

      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "lsb_release - print distribution-specific information"
         echo "The  lsb_release command provides certain LSB (Linux Standard Base) and"
         echo "distribution-specific information."
         echo
         echo "Usage:" 
         echo "If no options are given, the -v option is assumed."
         echo
         echo "lsb_release [OPTIONS]"
         echo "            -v, --version   Version of lsb_release."
         echo "            -i, --id        Display the distributor's ID."
         echo "            -r, --release   Display the release number."
         echo "            -c, --codename  Display the code name of the currently installed"
         echo "                            distribution."
         echo "            -a, --all       Display all of the above information."
         echo
         echo "Now run lsb_release. Usage: 'lsb_release -a'"
         APP_NAME="lsb_release -a"
         f_press_enter_key_to_continue
      fi
} # End of f_lsb_release
#
# +----------------------------------------+
# |             Function f_lshw            |
# +----------------------------------------+
#
f_lshw () {

      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "lshw - Displays main board information"
         echo
         echo "Usage:"
         echo "lshw [ -version ]"
         echo "lshw [ -help ]"
         echo "lshw [ -X ]"
         echo "lshw  [ -html ] [ -short ] [ -xml ] [ -json ] [ -businfo ] [ -dump filename ]"
         echo "[ -class class... ] [ -disable test... ] [ -enable test... ] [ -sanitize ]"
         echo "[ -numeric ] [ -quiet ]"
         echo
         echo "*** For more help type: 'man lshw'"
         echo "                'lshw --help'"
         echo
         echo "Display short report."
         echo
         echo "Now run lshw. Usage: lshw -short"
         echo
         echo "Please wait a few moments as the report is completed."
         APP_NAME="lshw -short"
         f_press_enter_key_to_continue
      fi
} # End of f_lshw
#
# +----------------------------------------+
# |            Function f_lspcmcia         |
# +----------------------------------------+
#
f_lspcmcia () {
      clear # Blank the screen.
      echo "lspcmcia - Display extended PCMCIA debugging information."
      echo
      echo "lspcmcia is an alias for pccardctl ls, provided for convenience."
      echo
      echo "Usage:"
      echo "lspcmcia [-V] [-v ...] [socket]"
      echo
      echo "*** For more help type: 'man lspcmcia'"
      echo "                        'lspcmcia --help'"
      echo
      f_press_enter_key_to_continue
} # End of f_lspcmcia
#
# +----------------------------------------+
# |              Function f_lspci          |
# +----------------------------------------+
#
f_lspci () {
      clear # Blank the screen.
      echo "lspci - list all PCI devices with detailed information."
      echo
      echo "Usage:"
      echo "lspci [OPTIONS]"
      echo
      echo "OPTIONS"
      echo "   Basic display modes"
      echo "       -m     List PCI devices in a backward-compatible machine readable form."
      echo "       -mm    List PCI devices in a machine readable form for easy parsing."
      echo "       -t     Show  a tree-like diagram with all buses, bridges, devices etc."
      echo
      echo "   Display options"
      echo "       -v     Be verbose and display detailed information about all devices."
      echo "       -vv    Be very verbose and display more details."
      echo "       -vvv   Be  even  more  verbose."
      echo
      echo "*** For more help type: 'man lspci'"
      echo "                        'lspci --help'"
      echo
      echo "Now run lspci. Usage: lspci -tvv"
      APPNAME="lspci -tvv"
      f_press_enter_key_to_continue
} # End of f_lspci
#
# +----------------------------------------+
# |             Function f_mpstat          |
# +----------------------------------------+
#
f_mpstat () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "mpstat - Display CPU statistics."
         echo
         echo "Usage:"
         echo "mpstat [ -A ] [ -I { SUM | CPU | SCPU | ALL } ] [ -u ]"
         echo "[ -P { cpu [,...] | ON | ALL } ] [ -V ] [ interval [ count ] ]"
         echo
         echo "*** For more help type: 'man mpstat'"
         echo "                        'mpstat --help'"
         echo
         echo "mpstat this PC's CPU (localhost) for 5 times every 2 seconds as an example."
         echo
         echo "Now run mpstat. Usage: dstat 2 5"
         APP_NAME="mpstat 2 5"
         f_press_enter_key_to_continue
      fi
} # End of f_mpstat
#
# +----------------------------------------+
# |            Function f_pccardctl        |
# +----------------------------------------+
#
f_pccardctl () {
      clear # Blank the screen.
      echo "pccardctl - PCMCIA card control utility."
      echo
      echo "pccardctl  is  used  to monitor and control the state of PCMCIA sockets."
      echo "If a socket number is specified, the command will be applied to just one"
      echo "socket; otherwise, all sockets will be affected."
      echo
      echo "If pccardctl is executed by root, all commands are available."
      echo "If it is executed by an unprivileged user, only the informational commands"
      echo "are accessible."
      echo
      echo "Usage:"
      echo "pccardctl [-V] [-v ...] command [socket]"
      echo
      echo "*** For more help type: 'man pccardctl'"
      echo "           'pccardctl --help'"
      f_press_enter_key_to_continue
} # End of f_pccardctl
#
# +----------------------------------------+
# |             Function f_pidstat         |
# +----------------------------------------+
#
f_pidstat () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "pidstat - View system processes/resources, PID/USR/System/Guest/CPU/Cmd."
         echo
         echo "pidstat this PC's CPU (localhost) for 3 times every 2 seconds as an example."
         echo
         echo "*** For more help type: 'man pidstat'"
         echo "                        'pidstat --help'"
         echo
         echo "Now run pidstat. Usage: pidstat 2 3"
         APP_NAME="pidstat 2 3"
         f_press_enter_key_to_continue
      fi
} # End of f_pidstat
#
# +----------------------------------------+
# |              Function f_ps             |
# +----------------------------------------+
#
f_ps () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "ps - View system processes/resources, PID/PGID/SID/TTY/Time/Cmd."
         echo
         echo "Usage:"
         echo "To see every process on the system using standard syntax:"
         echo "[ps -e ] [ ps -ef ] [ ps -eF ] [ ps -ely ]"
         echo
         echo "To see every process on the system using BSD syntax:"
         echo "[ ps ax] [ ps axu ]"
         echo
         echo "To print a process tree:"
         echo "[ ps -ejH ] [ ps axjf ]"
         echo
         echo "To get info about threads:"
         echo "[ ps -eLf ] [ ps axms ]"
         echo
         echo "To see every process running as root (real & effective ID) in user format:"
         echo "[ ps -U root -u root u ]"
         echo
         echo "*** For more help type: 'man ps'"
         echo "                        'ps --help'"
         echo
         echo "Now run ps. Usage: ps -ejH"
         APP_NAME="ps -ejH"
         f_press_enter_key_to_continue
      fi
} # End of f_ps
#
# +----------------------------------------+
# |          Function f_pswatcher          |
# +----------------------------------------+
#
f_pswatcher () {
      clear # Blank the screen.
      echo "pswatcher - Monitor a system via ps-like commands."
      echo
      echo "This program runs the ps command periodically and triggers commands on matches."
      echo "The match patterns are Perl regular expressions which can refer to the process"
      echo "information via variables."
      echo "For example it can be used to ensure that a daemon is running, or is not"
      echo "running too many times. It can also be used to determine when a process has"
      echo "consumed too many resources, perhaps due to a memory leak."
      echo "Homepage: http://ps-watcher.sourceforge.net/"
      echo
      echo "*** For more help type: 'man $APP_NAME'"
      echo "                        '$APP_NAME --help'"
      echo
      f_press_enter_key_to_continue
} # End of f_pswatcher
#
# +----------------------------------------+
# |             Function f_pydf            |
# +----------------------------------------+
#
f_pydf () {
      clear # Blank the screen.
      echo "pydf - Displays free space on disk"
      echo
      echo "Usage:"
      echo "pydf [OPTION]... [FILE]..."
      echo "   -h, --human-readable    format (e.g., 1K 234M 2G)"
      echo "   -k, --kilobytes"
      echo "   -m, --megabytes"
      echo "   -g, --gigabytes"
      echo
      echo "*** For more help type: 'man df'"
      echo "                        'df --help'"
      echo
      echo "Display total disk usage in human-readable format."
      echo
      echo "Now run df. Usage: pydf -hT"
      APP_NAME="pydf -hT"
      f_press_enter_key_to_continue
} # End of function f_pydf
#
# +----------------------------------------+
# |            Function f_rrdtool          |
# +----------------------------------------+
#
f_rrdtool () {
      clear # Blank the screen.
      echo "rrdtool   - The Round Robin Database Tool stores/displays time-series data."
      echo
      echo "The Round Robin Database Tool (RRDtool) is a system to store and display"
      echo "time-series data (e.g. network bandwidth, machine-room temperature,"
      echo "server load average). It stores the data in Round Robin Databases (RRDs),"
      echo "a very compact way that will not expand over time. RRDtool processes the"
      echo "extracted data to enforce a certain data density, allowing for useful"
      echo "graphical representation of data values."
      echo
      echo "RRDtool is often used via various wrappers that can poll data from devices"
      echo "and feed data into RRDs, as well as provide a friendlier user interface and"
      echo "customized graphs."
      echo
      echo "*** For more help type: 'man rrdtool'"
      echo "                        'rrdtool --help'"
      echo
      f_press_enter_key_to_continue
} # End of f_rrdtool
#
# +----------------------------------------+
# |            Function f_slabtop          |
# +----------------------------------------+
#
f_slabtop () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "slabtop - Display kernel slab cache information in real time."
         echo
         echo "slabtop displays a listing of the top caches sorted by  one  of  the  listed"
         echo "sort  criteria.   It also displays a statistics header filled with slab"
         echo "layer information."
         echo
         echo "Usage:"
         echo "slabtop [OPTIONS]"
         echo
         echo "slabtop  displays  detailed kernel slab cache information in real time."
         echo
         echo "*** For more help type: 'man slabtop'"
         echo "                        'slabtop --help'"
         echo
         echo "If you get error message: 'fopen /proc/slabinfo: Permission denied'"
         echo "Then try running with sudo command i.e. 'sudo slabtop'."
         echo
         f_press_enter_key_to_continue
      fi
} # End of f_slabtop
#
# +----------------------------------------+
# |            Function f_smb-nat          |
# +----------------------------------------+
#
f_smb-nat () {
      clear # Blank the screen.
      echo "smb-nat    - Netbios Auditing of servers running NetBIOS file sharing services."
      echo
      echo "This tool can perform various security checks on remote servers running"
      echo "NetBIOS file sharing services. It is capable of enumerating shares and make"
      echo "break-in attempts using a (user-provided) list of users and passwords."
      echo
      echo "*** For more help type: 'man $APP_NAME'"
      echo "                '$APP_NAME --help'"
      echo
      f_press_enter_key_to_continue

} # End of function f_smb-nat
#
# +----------------------------------------+
# |            Function f_stress           |
# +----------------------------------------+
#
f_stress () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "stress - A tool to impose load on and stress test a computer system"
         echo
         echo "The application, 'stress' is a tool that imposes a configurable amount of CPU,"
         echo "memory, I/O, or disk stress on a POSIX-compliant operating system and reports"
         echo "any errors it detects."
         echo
         echo "The application 'stress' is not a benchmark."
         echo
         echo "It is a tool used by:"
         echo "System Administrators to evaluate how well their systems will scale,"
         echo "Kernel Programmers to evaluate perceived performance characteristics, and by"
         echo "Systems Programmers to expose the classes of bugs which only or more frequently"
         echo "manifest themselves when the system is under heavy load."
         echo
         echo "*** For more help type: 'man $APP_NAME'"
         echo "                '$APP_NAME --help'"
         echo
         f_press_enter_key_to_continue
      fi
} # End of function f_stress
#
# +----------------------------------------+
# |            Function f_sysctl           |
# +----------------------------------------+
#
f_sysctl () {
      clear # Blank the screen.
      echo "sysctl - Configure kernel parameters at runtime."
      echo
      echo "sysctl is used to modify kernel parameters at runtime."
      echo "The parameters available are those listed under /proc/sys/."
      echo "Procfs is required for sysctl support in Linux.  You can use sysctl to both"
      echo "read and write sysctl data."
      echo
      echo "Usage:"
      echo "       sysctl [-n] [-e] variable ..."
      echo "       sysctl [-n] [-e] [-q] -w variable=value ..."
      echo "       sysctl [-n] [-e] [-q] -p [filename]"
      echo "       sysctl [-n] [-e] -a"
      echo "       sysctl [-n] [-e] -A"
      echo
      echo "EXAMPLES"
      echo "       /sbin/sysctl -a"
      echo "       /sbin/sysctl -n kernel.hostname"
      echo "       /sbin/sysctl -w kernel.domainname='example.com'"
      echo "       /sbin/sysctl -p /etc/sysctl.conf"
      echo
      echo "*** For more help type: 'man $APP_NAME'"
      echo "                        '$APP_NAME --help'"
      f_press_enter_key_to_continue
} # End of f_sysctl
#
# +----------------------------------------+
# |           Function f_tripwire          |
# +----------------------------------------+
#
f_tripwire () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "tripwire - Detects unauthorized file changes"
         echo
         echo "*** For more help type: 'man tripwire' for use and operation."
         echo "*** For more help type: 'man twadmin' - create, encode policy, config files."
         echo "*** For more help type: 'man twprint' - print database."
         echo "*** For more help type: 'man siggen' - display hash values for files."
         echo "*** For more help type: 'man twconfig' - explanation of config files."
         echo "*** For more help type: 'man twpolicy' - explanation of policy files."
         echo "*** For more help type: 'man twfiles' - overview of files, settings."
         echo
         echo "Usage:"
         echo "Database Initialization:  tripwire [-m i|--init] [OPTIONS]"
         echo "Integrity Checking:  tripwire [-m c|--check] [object1 [object2...]]"
         echo "Database Update:  tripwire [-m u|--update]"
         echo "Policy Update:  tripwire [-m p|--update-policy] policyfile.txt"
         echo "Test:  tripwire [-m t|--test] --email address"
         echo "Type 'tripwire [mode] --help' OR"
         echo "'tripwire --help mode [mode...]' OR"
         echo "'tripwire --help all' for extended help"
         echo
         echo "Now run man tripwire. Usage: man tripwire"
         echo
         APP_NAME="man tripwire"
         f_press_enter_key_to_continue
      fi
} # End of function f_tripwire
#
# +----------------------------------------+
# |             Function f_uuid            |
# +----------------------------------------+
#
f_uuid () {
      clear # Blank the screen.
      echo "To find the UUID of a disk, type: ls -l /dev/disk/by-uuid."
      APP_NAME="ls -l /dev/disk/by-uuid"
      f_application_run             
      f_press_enter_key_to_continue
} # End of function f_uuid
#
# +----------------------------------------+
# |             Function f_uname           |
# +----------------------------------------+
#
f_uname () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "uname - print system information"
         echo
         echo "Usage:" 
         echo "If no options are given, the -s option is assumed."
         echo
         echo "uname [OPTIONS]"
         echo "      -a, --all  print  all  information."
         echo "      -s, --kernel-name"
         echo "      -r, --kernel-release"
         echo "      -v, --kernel-version"
         echo "      -m, --machine    print the machine hardware name"
         echo "      -p, --processor"
         echo "      -i, --hardware-platform"
         echo "      -o, --operating-system"
         echo
         echo "Now run uname. Usage: uname -a"
         APP_NAME="uname -a"
         f_press_enter_key_to_continue
      fi
} # End of f_uname
#
# +----------------------------------------+
# |           Function f_wall              |
# +----------------------------------------+
#
f_wall () {
      # If APP_NAME has no spaces, then neither [OPTIONS] nor file are specified.
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "wall - Write a message to users."
         echo
         echo "Usage:"
         echo "wall [options] [<file>]"
         echo
         echo "Options:"
         echo "-n, --nobanner          do not print banner, works only for root"
         echo "-t, --timeout <timeout> write timeout in seconds"
         echo "-V, --version           output version information and exit"
         echo "-h, --help              display this help and exit"
         echo
         echo "*** For more help type: 'man wall'" 
         echo "                        'wall --help'"
         echo
         echo "Now run wall and prompt for filename. Usage: less <filename>."
         echo
         echo -n "Enter name of text file to display to users: "
         read ANS
         if [ -z $ANS ] ; then   #String has zero length.
            echo
            echo "Missing filename."
            echo "Usage: wall <filename>"
            echo
            echo "Now run wall. Usage: wall --help"
            echo
            APP_NAME="wall --help"
            f_press_enter_key_to_continue
         elif [ -r $ANS ] ; then   #Filename exists and is readable.
            APP_NAME="wall $ANS"
         else
            echo "The file $ANS is either missing or cannot be read."
            echo "Missing or unreadable filename."
            echo "Usage: wall <filename>"
            echo
            echo "Now run wall. Usage: wall --help"
            echo
            APP_NAME="wall --help"
            f_press_enter_key_to_continue
         fi
      fi
} #End of function f_wall
#
