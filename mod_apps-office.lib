# Â©2014 Copyright 2014 Robert D. Chin
#
# +----------------------------------------+
# |             Revision Date              |
# +----------------------------------------+
# REVDATE="May 31, 2014 23:24"
#
# +----------------------------------------+
# |       Function f_menu_cat_office       |
# +----------------------------------------+
#
#  Inputs: None.
#    Uses: BOF, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_cat_office () {
      f_initvars_menu_app "BOF"
      until [ "$BOF" = "0" ]
      do    # Start of Office Application Category until loop.
#f_menu_app_accounting   #BOF Accounting   - Accounting (with with double-entry).
#f_menu_app_calculators  #BOF Calculators  - Simple "pocket" calculators.
#f_menu_app_calendar     #BOF Calendar     - Calendars.
#f_menu_app_clocks       #BOF Clocks       - Alarm clocks, specialized clocks.
#f_menu_app_contacts     #BOF Contacts     - Contact/Address book lists.
#f_menu_app_note         #BOF Notes        - Notebooks, diaries, PIM (personal information manager).
#f_menu_app_pdfps        #BOF PDF-PS docs  - view, edit, compare, merge pdf and ps documents.
#f_menu_app_presentation #BOF Presenters   - Text slideshow presentation.
#f_menu_app_spreadsheets #BOF Spreadsheets - Basic spreadsheet.
#f_menu_cat_text         #BOF Text         - Create/Edit text files, text format converters, etc.        
#f_menu_app_todo         #BOF To Do        - To-Do lists.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Office Application Category Menu"
            DELIMITER="#BOF" #BOF This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read BOF
            f_menu_item_process $BOF  # Outputs $MENU_ITEM. $BOF
      done  # End of Office Application Category until loop.
            #
      unset BOF MENU_ITEM  # Throw out this variable.
} # End of function f_menu_cat_office
#
# +----------------------------------------+
# |     Function f_menu_app_accounting     |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MAA, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_accounting () {
      f_initvars_menu_app "MAA"
      until [ "$MAA" = "0" ]
      do    # Start of Accounting Applications until loop.
#0^0^0^0^1 #MAA brinance      - Personal finance.
#0^0^0^0^1 #MAA chkbk         - Personal finance.
#0^0^0^0^1 #MAA clacct        - Account management for multiple users and accounts.
#0^0^0^0^1 #MAA clipf         - Track Your incomes and expenses, written for Python2.
#0^0^0^0^1 #MAA hledger       - Same as "ledger" but using the Haskell Programming Language.
#0^0^0^0^1 #MAA hledger-chart - Hledger pie chart generator.
#0^0^0^0^0 #MAA hledger-vty   - Hledger n-curses style interface.
#0^0^0^0^0 #MAA hledger-web   - Hledger web interface.
#0^0^0^0^1 #MAA ledger        - Ledger using double-entry.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Accounting Applications Menu"
            DELIMITER="#MAA" #MAA This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MAA
            f_menu_item_process $MAA  # Outputs $MENU_ITEM.
      done  # End of Accounting Applications until loop.
            #
      unset MAA MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_accounting
#
# +----------------------------------------+
# |     Function f_menu_app_calculators    |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MCC, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_calculators () {
      f_initvars_menu_app "MCC"
      until [ "$MCC" = "0" ]
      do    # Start of Calculator Applications until loop.
#0^0^0^0^0  #MCC apcalc   - Arbitrary precision calculator, uses C-like language.
#0^0^0^7^0  #MCC bc       - Calculator.
#0^0^0^0^0  #MCC concalc  - Calculator, parser-algorithm of extcalc.
#0^0^0^1^0  #MCC dc       - RPN arbitrary precision reverse-polish calculator.
#0^0^0^21^0 #MCC genius   - General purpose calculator.
#0^0^0^0^1  #MCC orpie    - RPN Reverse Polish Notation calculator.
#0^0^0^21^0 #MCC qalc     - Qalculate! calculator customizable functions, units, precision.
#0^0^0^0^0  #MCC rpncalc  - RPN calculator trying to emulate an HP28S.
#0^0^0^1^0  #MCC tapecalc - Tape-like calculator.
#0^0^0^1^0  #MCC wcalc    - Scientific calculator.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Calculator Applications Menu"
            DELIMITER="#MCC" #MCC This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MCC
            f_menu_item_process $MCC  # Outputs $MENU_ITEM.
      done  # End of Calculator Applications until loop.
            #
      unset MCC MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_calculators
#
# +----------------------------------------+
# |      Function f_menu_app_calendar      |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MCA, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_calendar () {
      f_initvars_menu_app "MCA"
      until [ "$MCA" = "0" ]
      do    # Start of Calendar Applications until loop.
#0^0^0^0^1 #MCA cal         - Displays a monthly calendar.
#0^0^0^1^0 #MCA calcurse    - Calendar and To-Do List; ncurses-based.
#0^0^0^0^1 #MCA ccal        - Calendar in color, "cal"-like but with color.
#0^0^0^0^1 #MCA clcal       - Calendar and appointment reminders.
#0^0^0^0^1 #MCA dadd        - Date arithmetic using minutes, hours, days, weeks.
#0^0^0^0^1 #MCA dconv       - Convert a date between calendric systems.
#0^0^0^0^1 #MCA ddiff       - Calculate difference in days between dates.
#0^0^0^0^1 #MCA dgrep       - Grep dates from text using < or > signs.
#0^0^0^0^1 #MCA dround      - Round off dates or timestamps i.e. next/previous Day/Month.
#0^0^0^0^1 #MCA dseq        - seq command for dates/times, compute series of dates.
#0^0^0^0^1 #MCA dtest       - Like the test command but for dates.
#0^0^0^0^1 #MCA emacs-calfw - Displays a calendar view in the Emacs buffer.
#0^0^0^0^1 #MCA etm         - Event and task manager.
#0^0^0^0^1 #MCA gcal        - Calendar, almost the same as cal.
#0^0^0^0^1 #MCA gcalcli     - Google calendar.
#f_menu_app_calendar2^0^0^0^0 #MCA MORE...     - More calendar applications.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Calendar Applications Menu"
            DELIMITER="#MCA" #MCA This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MCA
            f_menu_item_process $MCA  # Outputs $MENU_ITEM.
      done  # End of Calendar Applications until loop.
            #
      unset MCA MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_calendar
#
# +----------------------------------------+
# |      Function f_menu_app_calendar2     |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MCB, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_calendar2 () {
      f_initvars_menu_app "MCB"
      until [ "$MCB" = "0" ]
      do    # Start of Calendar2 Applications until loop.
#0^0^0^0^1 #MCB hebcal    - Perpetual Jewish calendar.
#0^0^0^0^1 #MCB ical2rem  - iCalendar *.ics (Google, Yahoo, Lotus Notes) to Remind format.
#0^0^0^0^1 #MCB jcal      - Display Jalali (Persian) calendar.
#0^0^0^0^1 #MCB lunar     - Converts Gregorian date to Chinese lunar calendar.
#0^0^0^0^1 #MCB mencal    - Calendar to track repeating periodic events every nn days.
#0^0^0^0^1 #MCB ncal      - Calendar with vertical days.
#0^0^0^0^1 #MCB pal       - Calendar with events.
#0^0^0^0^1 #MCB pcal      - Generate PostScript or HTML Calendars.
#0^0^0^0^1 #MCB pom       - Display phase of moon on given date.
#0^0^0^0^1 #MCB remind    - Calendar alarms, Sun rise/set, moon phases.
#0^0^0^0^1 #MCB remupdate - Download Google Calendars then converts to "Remind" format.
#0^0^0^0^1 #MCB strptime  - Easily format dates any way you want.
#0^0^0^0^1 #MCB when      - Calendar.
#0^0^0^1^0 #MCB wyrd      - Calendar, ncurses-based front-end for "Remind".
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Calendar2 Applications Menu"
            DELIMITER="#MCB" #MCB This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MCB
            f_menu_item_process $MCB  # Outputs $MENU_ITEM.
      done  # End of Calendar2 Applications until loop.
            #
      unset MCB MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_calendar2
#
# +----------------------------------------+
# |       Function f_menu_app_clocks       |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MCL, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_clocks () {
      f_initvars_menu_app "MCL"
      until [ "$MCL" = "0" ]
      do    # Start of Clock Applications until loop.
#1^0^0^0^1 #MCL binclock         - Binary clock.
#0^0^0^0^1 #MCL binary-clock     - Binary numbers 1/0 tells time.
#0^1^0^8^0 #MCL cclock           - Digital clock with huge numbers fills entire screen.
#0^0^0^0^0 #MCL clockywock       - Analog clock, ncurses-based.
#0^0^0^0^1 #MCL grandfatherclock - Clock chimes Big-Ben, Cuckoo, 'Close Encounters'.
#0^0^0^0^1 #MCL leave            - Text "alarm" tells you when it's time to leave.
#0^0^0^0^1 #MCL saytime          - Audio clock.
#0^0^0^0^1 #MCL tbclock          - Binary clock, binary numbers 1/0 tells time.
#0^0^0^0^1 #MCL tzwatch          - Displays time/date in specified time zones on console.
#0^0^0^8^0 #MCL vtclock          - Full-screen clock also shows 1 line text, ncurses-based.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Clock Applications Menu"
            DELIMITER="#MCL" #MCL This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MCL
            f_menu_item_process $MCL  # Outputs $MENU_ITEM.
      done  # End of Clock Applications until loop.
            #
      unset MCL MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_clocks
#
# +----------------------------------------+
# |          Function f_binclock           |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: None.
# Outputs: None.
#
f_binclock () {
      clear  # blank screen
      echo "binclock - Display binary clock on console."
      echo
      echo "Usage: binclock [OPTIONS]"

      echo "Short options:"
      echo "-v      print the version number + release date + exit."
      echo "-h      print version info and startup options  + exit."
      echo "-l      loop the time every second."
      echo "-n      shows the time with an additional normal format."
      echo "-t      show traditional binary output (without color)"
      echo
      echo "long options:"
      echo "--color=[on|off] default: on"
      echo
      echo "Now run binclock. Usage: binclock -nl"
      APP_NAME="binclock -nl"
      echo
      f_run_and_exit "binclock" "binclock -nl"
} # End of f_binclock
#
# +----------------------------------------+
# |       Function f_install_cclock        |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: None.
# Outputs: None.
#
f_install_cclock () {
      if [ ! -r "/usr/bin/cclock" ] ; then
         clear  # blank screen
         echo "This script will install \"cclock\" without using a software package manager."
         echo
         echo "If you wish to de-install \"'cclock\", you will have to delete files manually"
         echo "by typing: \"sudo rm /usr/bin/cclock /usr/share/man/man1/cclock.1\"."
         echo
         echo "This script will install \"libncurses-dev\" and \"ncurses-dev\", if needed."
         echo "Afterwards, \"cclock\" will be installed."
         echo
         echo -n "Do you wish to continue (y/N)? "
         read ANS
         #
         # Yes, Install cclock.
         if [ "$ANS" = "Y" -o "$ANS" = "y" ] ; then
            # Install libncurses-dev and ncurses-dev as pre-requisites.
            f_ncurses
            if [ "$ERROR" = "0" ] ; then
               # Error code 1 $?=1 means no --help available.
               # Error code 0 (zero) where $?=0 means no error.
               #
               # Since dependencies are installed, now install Ztrack.
               f_install2_cclock
               APP_NAME="cclock" # Set to correct name for f_application_run.
               APP_NAME_INSTALL=$APP_NAME # Set for web_install if needed.
            fi
         else
            # No, Do not install cclock.
            MENU_ITEM_NAME="" # Null so f_application_run does not try to run cclock.
                              # when it's not installed.
            APP_NAME=""       # Also prevents checking for Quit Clause.
            PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
         fi
         unset ANS
      fi
} # End of f_install_cclock
#
# +----------------------------------------+
# |         Function f_install2_cclock     |
# +----------------------------------------+
#
#  Inputs: None.
#    Uses: ANS.
# Outputs: APP_NAME, MENU_ITEM (both set to null).
#
f_install2_cclock () {
      clear  # blank screen
      echo "This script will automatically download and install \"cclock\"."
      echo
      echo "This script will do the following:"
      echo "1. Change directory to your home folder."
      echo "2. Download \"cclock\" using wget from:"
      echo "   http://sourceforge.net/projects/cclock/files/latest/download"
      echo "3. Decompress and create the installation subdirectory ~/bin/cclock*"
      echo "4. Install cclock via:"
      echo "                           sudo make install"
      echo
      echo "   Installs files to \"/usr/bin/\" and \"/usr/share/man/man1/cclock.1\"."
      echo
      echo "5. Allow users to run cclock by setting permissions to r-x or 755 for all users."
      echo "6. Add directory \"/usr/bin\" to your PATH command in ~/.bashrc."
      echo
      echo
      echo -n "Press '"Enter"' key to continue."
      read X
      unset X  # Throw out this variable.
      #
      # 1. Change directory to your home/bin folder.
      cd ~
      if [ ! -d "~/bin" ] ; then
         # Target directory is missing, so create it.
	 mkdir ~/bin
      fi
      # 
      # 2. Download "cclock" from "http://sourceforge.net/projects/cclock/files/latest/download"
      #    by using wget.
      cd ~/bin
      wget http://sourceforge.net/projects/cclock/files/latest/download/cclock-0.96.tar.bz2
      #
      # 3. Decompress and create the installation subdirectory ~/bin/cclock*.
      tar -xf cclock*
      #
      # 4. Make and install cclock.
      cd ~/bin/cclock*
      sudo make install
      #
      # 5. Allow users to run cclock by setting permissions to r-x or 755 for all users.
      sudo chmod 755 /usr/bin/cclock*
      #
      # 6. Add directory \"/usr/bin\" to your PATH command in ~/.bashrc.
      # Is the directory /usr/bin in your PATH of directories?
      # Check the $PATH
      if [[ ! "$PATH" == *":/usr/bin"* ]] ; then
         echo "If needed, edit file \"~/.bashrc\" PATH."
         echo "Append the directory name to your environment $PATH."
         echo $(tput bold)'PATH=$PATH'":/usr/bin"
         echo "export PATH"
         echo
         echo "       >>> IMPORTANT <<<"
         echo "After editing the file, .bashrc:"
         echo "Close Terminal for changes to take effect."
         echo "Either logout or exit from Terminal and re-launch Terminal."
         echo
      fi
      echo
      echo "Finished running installation script for \"cclock\"."
      echo
      echo -n "Press '"Enter"' key to continue."
      read X
      unset X  # Throw out this variable.
} # End of function f_install2_cclock
#
# +----------------------------------------+
# |      Function f_menu_app_contacts      |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MCO, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_contacts () {
      f_initvars_menu_app "MCO"
      until [ "$MCO" = "0" ]
      do    # Start of Contact List Applications until loop.
#0^0^0^0^1 #MCO abook - Address book with or w/o mutt. With tabs for fields of information.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Contact List Applications Menu"
            DELIMITER="#MCO" #MCO This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MCO
            f_menu_item_process $MCO  # Outputs $MENU_ITEM.
      done  # End of Contact List Applications until loop.
            #
      unset MCO MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_contacts
#
# +----------------------------------------+
# |         Function f_menu_app_note       |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MNO, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_note () {
      f_initvars_menu_app "MNO"
      until [ "$MNO" = "0" ]
      do    # Start of Note Applications until loop.
#0^0^0^0^1 #MNO cjots    - Notebook with books, pages, notes (to-do lists), etc.
#0^0^0^0^1 #MNO diary    - Diary and To Do List uses commands date, grep, and text editor.
#0^0^0^0^1 #MNO diary-f  - Fork of "diary" enhanced "view"/"cat" actions, non-latin locales.
#0^0^0^0^1 #MNO hnb      - Hierarchical notebook.
#0^0^0^0^1 #MNO nodau    - Note-taking with search by name or date.
#0^0^0^0^1 #MNO note     - Manage notes with a DBI-based mysql-module.
#0^0^0^0^1 #MNO org-mode - Emacs plugin for notes, ToDo lists, and project planning.
#0^0^0^0^0 #MNO tina     - PIM (personal information manager), ncurses-based.
#0^0^0^0^1 #MNO worklog  - Time-tracking for projects/tasks, running clock, ncurses-based.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Note Applications Menu"
            DELIMITER="#MNO" #MNO This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MNO
            f_menu_item_process $MNO  # Outputs $MENU_ITEM.
            #
            # If application displays information, allow user to read it.
            f_option_press_enter_key
      done  # End of Note Applications until loop.
            #
      unset MNO MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_note
#
# +----------------------------------------+
# |       Function f_menu_app_pdfps        |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MPS, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_pdfps () {
      f_initvars_menu_app "MPS"
      until [ "$MPS" = "0" ]
      do    # Start of PDF and PS Applications until loop.
#0^0^0^0^1 #MPS comparepdf - Compare two PDF files.
#0^0^0^0^1 #MPS diffpdf    - Compare two PDF files.
#0^0^0^0^1 #MPS enscript   - Convert text file to Post-Script file.
#0^0^0^0^1 #MPS fbdjvu     - DjVu viewer similar to fbpdf.
#0^0^0^0^1 #MPS fbgs       - GhostScript, PostScript, and PDF viewer.
#0^0^0^0^1 #MPS fbpdf      - Framebuffer PDF viewer based on MuPDF with Vim keybindings.
#0^0^0^0^1 #MPS gs         - GhostScript, PostScript, and PDF viewer.
#0^0^0^0^1 #MPS jfbview    - Image viewer and framebuffer PDF viewer based on Imlib2.
#0^0^0^0^1 #MPS pdfgrep    - Search PDF files with filename, page, count and color output.
#0^0^0^0^1 #MPS pdfjam     - Merge PDF files into a single file.
#0^0^0^0^1 #MPS pdftex     - Typesetter creates PDF files.
#0^0^0^0^1 #MPS pdftk      - Merge/split, rotate, watermark, bookmarks/metadata, attach.
#0^0^0^0^1 #MPS pdftops    - Converts PDF to PS (PostScript) format.
#0^0^0^0^1 #MPS pstotext   - Extract text from PS  (PostScript) and PDF files.
#0^0^0^0^1 #MPS ps2ascii   - Converts PS (PostScript) to text format.
#f_menu_app_pdfps2^0^0^0^0 #MPS MORE...    - For more PDF and PS applications.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="PDF/PS File Applications Menu"
            DELIMITER="#MPS" #MPS This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MPS
            f_menu_item_process $MPS  # Outputs $MENU_ITEM.
      done  # End of PDF and PS Applications until loop.
            #
      unset MPS MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_pdfps
#
# +----------------------------------------+
# |       Function f_menu_app_pdfps2       |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MPT, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_pdfps2 () {
      f_initvars_menu_app "MPT"
      until [ "$MPT" = "0" ]
      do    # Start of PDF and PS #2 Applications until loop.
#0^0^0^0^1 #MPT ps2pdf - Converts PS (PostScript) to PDF format.
#0^0^0^0^1 #MPT sdf    - Uses simple markup language output formats PS/PDF/HTML/RTF etc.
#0^0^0^0^1 #MPT sdop   - Converts a Simplified Docbook XML file to PS (PostScript).
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="PDF/PS File2 Applications Menu"
            DELIMITER="#MPT" #MPT This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MPT
            f_menu_item_process $MPT  # Outputs $MENU_ITEM.
      done  # End of PDF and PS #2 Applications until loop.
            #
      unset MPT MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_pdfps2
#
# +----------------------------------------+
# |    Function f_menu_app_presentation    |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MPR, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_presentation () {
      f_initvars_menu_app "MPR"
      until [ "$MPR" = "0" ]
      do    # Start of Presentation Applications until loop.
#0^0^0^0^0 #MPR tpp  - "Text Presentation Program", slideshow, ncurses-based.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Presentation Applications Menu"
            DELIMITER="#MPR" #MPR This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MPR
            f_menu_item_process $MPR  # Outputs $MENU_ITEM.
      done  # End of Presentation Applications until loop.
            #
      unset MPR MENU_ITEM  # Throw out this variable.
} # End of function f_menu_app_presentation
#
# +----------------------------------------+
# |    Function f_menu_app_spreadsheets    |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSP, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_spreadsheets () {
      f_initvars_menu_app "MSP"
      until [ "$MSP" = "0" ]
      do    # Start of Spreadsheet Applications until loop.
#0^0^0^0^0 #MSP csvkit  - Suite of utilities for converting to and working with CSV.
#0^0^0^0^1 #MSP oleo    - Full-screen spreadsheet having a more Emacs-like feel.
#0^0^0^0^1 #MSP sc      - Spreadsheet.
#0^0^0^0^1 #MSP slsc    - Spreadsheet based on sc.
#0^0^0^0^1 #MSP xls2csv - Microsoft Excel to *.csv (comma separated values) converter.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Spreadsheet Applications Menu"
            DELIMITER="#MSP" #MSP This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSP
            f_menu_item_process $MSP  # Outputs $MENU_ITEM.
      done  # End of Spreadsheet Applications until loop.
            #
      unset MSP MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_spreadsheets
#
# +----------------------------------------+
# |         Function f_menu_cat_text       |
# +----------------------------------------+
#
#  Inputs: None
#    Uses: BTX, MENU_ITEM, MAX
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_cat_text () {
      f_initvars_menu_app "BTX"
      until [ "$BTX" = "0" ]
      do    # Start of Text Application Category until loop.
#f_menu_app_text_compare         #BTX Compare         - Show differences between text files.
#f_menu_app_text_converters      #BTX Converters      - Convert between text document/file formats.
#f_menu_app_text_editors         #BTX Editors         - Create/Edit text documents/files.
#f_menu_app_text_markup_language #BTX Markup Docs     - Create a single source document, publish in many formats.
#f_menu_app_text_tools           #BTX Tools           - Viewers, spell-check, dictionaries.
#f_menu_app_text_word_processors #BTX Word Processors - Word processors, word processor file format converters.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Text Application Category Menu"
            DELIMITER="#BTX" #BTX This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read BTX
            f_menu_item_process $BTX  # Outputs $MENU_ITEM. $BTX
      done  # End of Text Application Category until loop.
            #
      unset BTX MENU_ITEM  # Throw out this variable.
} # End of function f_menu_cat_text
#
# +----------------------------------------+
# |    Function f_menu_app_text_compare    |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MTC, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_text_compare () {
      f_initvars_menu_app "MTC"
      until [ "$MTC" = "0" ]
      do    # Start of Text Compare Applications until loop.
#0^0^0^0^1 #MTC cmp       - Compares 2 text files.
#0^0^0^0^1 #MTC colordiff - Differences between 2 text files shown in color.
#1^0^0^0^1 #MTC comm      - Compares 2 sorted files line by line.
#0^0^0^0^1 #MTC diff      - Differences between 2 text files shown using <> signs.
#0^0^0^0^1 #MTC diff3     - Differences between 3 text files
#0^0^0^0^1 #MTC imediff2  - Interactive 2-way file merge.
#0^0^0^0^1 #MTC since     - Shows new changes in log files since last run. Tail work-alike.
#0^0^0^0^1 #MTC vimdiff   - Differences between 2 text files shown in color highlights.
#0^0^0^0^1 #MTC wdiff     - Differences between 2 text files shown using +/- signs.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Text Compare Applications Menu"
            DELIMITER="#MTC" #MTC This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MTC
            f_menu_item_process $MTC  # Outputs $MENU_ITEM.
      done  # End of Text Compare Applications until loop.
            #
      unset MTC MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_text_compare
#
# +----------------------------------------+
# |             Function f_comm            |
# +----------------------------------------+
#
f_comm () {
           clear # Blank the screen.
           echo "comm - compare two sorted files line by line." 
           echo
           echo "Usage:"
           echo "comm [OPTION]... FILE1 FILE2"
           echo
           echo "Output is in three columns of quoted lines."
           echo
           echo "  Column 1      Column 2          Column 3"
           echo "Lines unique  Lines unique      Lines common"
           echo "  to FILE1      to FILE2     to FILE1 and FILE2"
           echo
           echo "OPTIONS:"
           echo "         -1                 Suppress column 1."
           echo "         -2                 Suppress column 2."
           echo "         -3                 Suppress column 3."
           echo "         --no-check order   Do not check files for sort order."
           echo 
           echo "*** For more help type: 'man comm'"
           echo "                        'comm --help'"
           echo
           f_press_enter_key_to_continue
} # End of function f_comm
#
# +----------------------------------------+
# |   Function f_menu_app_text_converters  |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MTV, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_text_converters () {
      f_initvars_menu_app "MTV"
      until [ "$MTV" = "0" ]
      do    # Start of Text Converter Applications until loop.
#1^0^0^0^1 #MTV txt2html   - Converts plain ASCII text to HTML format.
#1^0^0^0^1 #MTV txt2man    - Converts plain ASCII text to man format.
#1^0^0^0^1 #MTV txt2pdbdoc - Converts plain ASCII text to PDB doc format for Palm Pilots.
#1^0^0^0^1 #MTV txt2regex  - Converts human sentences to regex. Regular Expression Wizard.
#1^0^0^0^1 #MTV txt2tags   - Converts plain ASCII text to a variety of formats.
#0^0^0^0^1 #MTV unoconv    - Converts any document format that LibreOffice imports/exports.
#0^0^0^0^1 #MTV unrtf      - Converts RTF to HTML, LaTeX, txt, PS.
#0^0^0^0^1 #MTV wp2x       - Converts WordPerfect 5.x documents to HTML, LaTeX, txt, troff.
#0^0^0^0^1 #MTV wpd2odt    - WordPerfect to OpenDocument converter.
#0^0^0^0^1 #MTV wpg2odg    - WordPerfect Graphics to OpenDocument converter.
#0^0^0^0^1 #MTV wps2odt    - Microsoft Works text documents to OpenDocument converter.
#0^0^0^0^1 #MTV xmlto      - Converts XML to DVI XSL-FO, HTML, XHTML, epub, man, PDF, PS.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Text Converter Applications Menu"
            DELIMITER="#MTV" #MTV This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MTV
            f_menu_item_process $MTV  # Outputs $MENU_ITEM.
      done  # End of Text Converter Applications until loop.
            #
      unset MTV MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_text_converters
#
# +----------------------------------------+
# |           Function f_txt2html          |
# +----------------------------------------+
#
f_txt2html () {
      # If APP_NAME has no spaces, then neither [OPTIONS] nor file name are specified.
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "txt2html - Convert plain text files to html." 
         echo
         echo "Usage:"
         echo "txt2html [ --append_file filename ] [ --append_head filename ]"
         echo "         [ --body_deco string ] [ --bold_delimiter string ]"
         echo "         [ --bullets string ] [ --bullets_ordered string ]"
         echo "         [ --caps_tag tag ]"
         echo
         echo "*** For more help type: 'man txt2html'"
         echo "                        'txt2html --help'"
         echo
         echo "Now show help. Usage: man txt2html"
         APP_NAME="man txt2html"
         f_press_enter_key_to_continue
      fi
} # End of function f_txt2html
#
# +----------------------------------------+
# |           Function f_txt2man           |
# +----------------------------------------+
#
f_txt2man () {
      # If APP_NAME has no spaces, then neither [OPTIONS] nor file name are specified.
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "txt2man - Convert plain text files to man pages." 
         echo
         echo "Usage:"
         echo "txt2man [-hpTX] [-t mytitle] [-P pname] [-r rel] [-s sect] [-v vol]"
         echo "        [-I txt] [-B txt] [-d date] [ifile]"
         echo
         echo "*** For more help type: 'man txt2man'"
         echo "                        'txt2man --help'"
         echo
         echo "Now show help. Usage: man txt2man"
         APP_NAME="man txt2man"
         f_press_enter_key_to_continue
      fi
} # End of function f_txt2man
#
# +----------------------------------------+
# |          Function f_txt2pdbdoc         |
# +----------------------------------------+
#
f_txt2pdbdoc () {
      # If APP_NAME has no spaces, then neither [OPTIONS] nor file name are specified.
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "txt2pdbdoc - Convert plain text files to (Palm Pilot Database) Doc file *.pdb."
         echo "             for PalmPilots & DocReaders. (Does anyone still have a PalmPilot?)"
         echo
         echo "Usage: txt2pdbdoc [-b] [-c] [-v] document-name file.txt file.pdb"
         echo "       txt2pdbdoc -d [-D] [-v] file.pdb [ file.txt ]"
         echo "       txt2pdbdoc -V"
         echo
         echo "*** For more help type: 'man txt2pdbdoc'"
         echo "                        'txt2pdbdoc --help'"
         echo
         echo "Now show help. Usage: man txt2pdbdoc"
         APP_NAME="man txt2pdbdoc"
         f_press_enter_key_to_continue
      fi
} # End of function f_txt2pdbdoc
#
# +----------------------------------------+
# |          Function f_txt2regex          |
# +----------------------------------------+
#
f_txt2regex () {
      # If APP_NAME has no spaces, then neither [OPTIONS] nor file name are specified.
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "txt2regex - Convert human sentences to regex." 
         echo
         echo "Usage:"
         echo "txt2regex --all|--prog <p1,p2,...,pN>"
         echo
         echo "*** For more help type: 'man txt2regex'"
         echo "                        'txt2regex --help'"
         echo
         echo "Now show help. Usage: man txt2regex"
         APP_NAME="man txt2regex"
         f_press_enter_key_to_continue
      fi
} # End of function f_txt2regex
#
# +----------------------------------------+
# |          Function f_txt2tags           |
# +----------------------------------------+
#
f_txt2tags () {
      # If APP_NAME has no spaces, then neither [OPTIONS] nor file name are specified.
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "txt2tags - Convert plain text files to ASCII Art, AsciiDoc, Creole, DocBook,"
         echo "           DokuWiki, Google Code Wiki, HTML, LaTeX, Lout, MagicPoint, Man page,"
         echo "           MoinMoin, PageMaker, Plain Text, PmWiki, SGML, Wikipedia and XHTML."
         echo 
         echo "Usage:"
         echo "txt2tags [OPTIONS] [FILE]... "
         echo
         echo "*** For more help type: 'man txt2tags'"
         echo "                        'txt2tags --help'"
         echo
         echo "Now show help. Usage: man txt2tags"
         APP_NAME="man txt2tags"
         f_press_enter_key_to_continue
      fi
} # End of function f_txt2tags
#
# +----------------------------------------+
# |     Function f_menu_app_text_editors   |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MTE, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_text_editors () {
      f_initvars_menu_app "MTE"
      until [ "$MTE" = "0" ]
      do    # Start of Text Editor Applications until loop.
#0^0^0^0^1  #MTE aee           - Advanced Easy Editor.
#0^0^0^0^0  #MTE aoeui         - Very small editor for Dvorak layout keyboards.
#0^0^0^15^0 #MTE dav           - Text editor.
#0^0^0^0^0  #MTE dex           - Support for ctags and parsing compiler errors.
#0^0^0^0^0  #MTE e3em          - Very small editor with emacs-like key bindings.
#0^0^0^0^0  #MTE e3vi          - Very small editor with vi-like key bindings.
#0^0^0^0^0  #MTE e3pi          - Very small editor with pico-like key bindings.
#0^0^0^0^0  #MTE e3ne          - Very small editor with nedit-like key bindings.
#0^0^0^0^0  #MTE e3ws          - Very small editor with Wordstar-like key bindings.
#0^0^0^0^0  #MTE ed            - Classic CLI text editor.
#0^0^0^0^0  #MTE efte          - Configurable editor, drop-down menus, ncurses-based.
#0^0^0^0^0  #MTE elvis-console - vi-clone. Multiple files/windows, spell-check, highlight.
#0^0^0^12^0 #MTE emacs         - Full screen text editor with plugins.
#0^0^0^0^0  #MTE enpi          - Bash script allows formatted text in text editors.
#0^0^0^0^0  #MTE fte-console   - fte for consoles, no internationalization I18N support.
#f_menu_app_text_editors2^0^0^0^0 #MTE MORE...       - For more text editor applications.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Text Editor Applications Menu"
            DELIMITER="#MTE" #MTE This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MTE
            f_menu_item_process $MTE  # Outputs $MENU_ITEM.
      done  # End of Text Editor Applications until loop.
            #
      unset MTE MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_text_editors
#
# +----------------------------------------+
# |    Function f_menu_app_text_editors2   |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MTF, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_text_editors2 () {
      f_initvars_menu_app "MTF"
      until [ "$MTF" = "0" ]
      do    # Start of Text Editor Applications2 until loop.
#0^0^0^0^0  #MTF fte-terminal - fte for xterm, vt100 terminals.
#1^0^0^0^0  #MTF groff        - Format text via macros, create man pages to PS printers.
#1^0^0^0^0  #MTF jed          - JED ncurses-based. Also consider package: jed-extra.
#0^0^0^12^0 #MTF jmacs        - Joe Editor, GNU-EMACS emulation mode.
#1^0^0^11^0 #MTF joe          - Joe editor. <Ctrl>-K H for help.
#0^0^0^12^0 #MTF jove         - Jonathan's Own Version of Emacs, ncurses-based.
#0^0^0^0^0  #MTF jpico        - Joe Editor, PICO emulation mode.
#0^0^0^0^0  #MTF jstar        - Joe Editor, WordStar emulation mode.
#0^0^0^0^0  #MTF jupp         - Fork of joe editor with enhancements.
#0^0^0^0^0  #MTF le           - LE editor text/hex mode, drop-down menus, ncurses-based.
#0^0^0^0^0  #MTF ledit        - line editor used with interactive commands.
#0^0^0^0^0  #MTF levi         - Very small vi-clone. From the 1980's.
#0^0^0^12^0 #MTF mg           - Microscopic GNU Emacs-style editor.
#0^0^0^0^0  #MTF nano         - Simple full-screen text editor more powerful than pico.
#0^0^0^0^0  #MTF nano-tiny    - tiny build of nano.
#f_menu_app_text_editors3^0^0^0^0 #MTF MORE...   - For more text editor applications.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Text Editor2 Applications Menu"
            DELIMITER="#MTF" #MTF This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MTF
            f_menu_item_process $MTF  # Outputs $MENU_ITEM.
      done  # End of Text Editor2 Applications until loop.
            #
      unset MTF MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_text_editors2
#
# +----------------------------------------+
# |    Function f_menu_app_text_editors3   |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MTG, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_text_editors3 () {
      f_initvars_menu_app "MTG"
      until [ "$MTG" = "0" ]
      do    # Start of Text Editor Applications until loop.
#0^0^0^0^0  #MTG ne              - Nice Editor. Drop-down menus, ncurses-based. 
#1^0^0^0^0  #MTG NERD_tree       - vim plug-in directory tree, highlighting, bookmarks, etc.
#0^0^0^14^0 #MTG nvi             - vi-clone as close to vi as possible.
#0^0^0^0^0  #MTG pico            - Simple full-screen text editor.
#f_joe^0^0^11:NC^0 #MTG rjoe            - Joe Editor, only edit file(s) specified rjoe <filenames>.
#0^0^0^0^0  #MTG the             - The Hessling Editor modeled on VM/CMS text editor, XEDIT.
#0^0^0^14^0 #MTG vi              - Classic full-screen text editor.
#0^0^0^14^0 #MTG vile            - "VI Like Emacs" vi "finger feel" but with emacs features.
#0^0^0^14^0 #MTG vim             - vi "Improved" text editor with more features than "vi".
#0^0^0^14^0 #MTG vim-nox         - vim with scripting support: Lua, Perl, Python, Ruby, TCL.
#0^0^0^14^0 #MTG vim-scripts     - plugins for vim, adding bells and whistles.
#0^0^0^14^0 #MTG vim-tiny        - Vi IMproved compact version.
#0^0^0^14^0 #MTG vim-latexsuite  - LaTeX plugin for vim.
#0^0^0^0^0  #MTG vim-vimoutliner - Script for building an outline editor on top of vim.
#0^0^0^0^0  #MTG zile            - Very small Emacs-subset editor.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Text Editor3 Applications Menu"
            DELIMITER="#MTG" #MTG This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MTG
            f_menu_item_process $MTG  # Outputs $MENU_ITEM.
      done  # End of Text Editor Applications until loop.
            #
      unset MTG MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_text_editors3
#
# +----------------------------------------+
# |            Function f_groff            |
# +----------------------------------------+
#
f_f_groff () {
      # If APP_NAME has no spaces, then neither [OPTIONS] nor file name are specified.
      if [[ ! "$APP_NAME" == *" "* ]] ; then
      clear # Blank the screen.
      echo "groff - Use macro command language to output formatted text"
      echo "        for PostScript printers."
      echo
      echo "Usage:" 
      echo "groff [-abcegiklpstzCEGNRSUVXZ] [-d cs] [-D arg] [-f fam] [-F dir] [-I dir]"
      echo "      [-K arg] [-L arg] [-m name] [-M dir] [-n num] [-o list] [-P arg]"
      echo "      [-r cn] [-T dev] [-w name] [-W name] [file ...]"
      echo "groff -h | --help"
      echo "groff -v | --version [OPTION ...]"
      echo
      echo "*** For more help type: 'man $APP_NAME'"
      echo "                        '$APP_NAME --help'"
      echo
      echo "Now show help. Usage: man $APP_NAME"
      APP_NAME="groff --help"
      f_press_enter_key_to_continue
      fi
} # End of function f_groff
#
# +----------------------------------------+
# |             Function f_jed             |
# +----------------------------------------+
#
f_jed () {
      APP_NAME_TMP=$MENU_ITEM # Save jed <OPTIONS>.
      APP_NAME="jed-extra"  # Install jed-extra package before running/installing jed.
      f_application_install_question
      APP_NAME=$APP_NAME_TMP
      PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
} # End of function f_jed
#
# +----------------------------------------+
# |             Function f_joe             |
# +----------------------------------------+
#
f_joe () {
      clear # Blank the screen.
      echo "joe - Text editor with 5 emulations of other text editors"
      echo
      echo "USAGE:" 
      echo "Regular Usage mode : joe [global-options] [ [local-options] filename ]..."
      echo " WordStar emulation: jstar [global-options] [ [local-options] filename ]..."
      echo "GNU-Emacs emulation: jmacs [global-options] [ [local-options] filename ]..."
      echo "    Restricted mode: rjoe [global-options] [ [local-options] filename ]..."
      echo "     PICO emulation: jpico [global-options] [ [local-options] filename ]..."
      echo
      echo "Available at: www.sourceforge.net/projects/joe-editor."
      echo
      echo "*** For more help type: 'man $APP_NAME'"
      echo "                        '$APP_NAME --help'"
      f_press_enter_key_to_continue
} # End of function f_jed
#
# +----------------------------------------+
# |          Function f_NERD_tree          |
# +----------------------------------------+
#
f_NERD_tree () {
      clear # Blank the screen.
      echo "NERD_tree - A vim plug-in displays a hierarchical directory tree."
      echo
      echo "FEATURES (from NERD tree web home page):"
      echo
      echo "The NERD tree allows you to explore your filesystem and to open files and"
      echo "directories. It presents the filesystem to you in the form of a tree which you"
      echo "manipulate with the keyboard and/or mouse. It also allows you to perform"
      echo "simple filesystem operations."
      echo
      echo "Files and directories are displayed in a hierarchical tree structure."
      echo "Color highlighting is provided for different types of nodes."
      echo "Directories and files can be bookmarked."
      echo "Most NERD tree navigation can also be done with the mouse."
      echo "Filtering of tree content (can be toggled at runtime)."
      echo "You can have a separate NERD tree for each tab, share trees across tabs, or a mix of both."
      echo "Many (customisable) mappings are provided to manipulate the tree."
      echo
      echo "*** For more help type: 'man $APP_NAME'"
      echo "                        '$APP_NAME --help'"
      f_press_enter_key_to_continue
} # End of function f_NERD_tree
#
# +----------------------------------------+
# |Function f_menu_app_text_markup_language|
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MTM, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_text_markup_language () {
      f_initvars_menu_app "MTM"
      until [ "$MTM" = "0" ]
      do    # Start of Text Markup Language Applications until loop.
#0^0^0^0^0 #MTM doconce - Markup language to manipulate, transform, and convert text.
#0^0^0^0^0 #MTM sisu    - Markup language, publishing, search, write to many formats.
#0^0^0^0^0 #MTM stx2any - Markup language, write to XHTML, HTML, XML, PS, LaTeX, etc.
#0^0^0^0^0 #MTM texinfo - Markup language produces both printed & on-line web pages.
#0^0^0^0^0 #MTM udo     - Simpler markup language writes to 25 formats.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Text Markup Language Applications Menu"
            DELIMITER="#MTM" #MTM This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MTM
            f_menu_item_process $MTM  # Outputs $MENU_ITEM.
      done  # End of Text Markup Applications until loop.
            #
      unset MTM MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_text_markup_language
#
# +----------------------------------------+
# |Function f_menu_app_text_word_processors|
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MTD, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_text_word_processors () {
      f_initvars_menu_app "MTD"
      until [ "$MTD" = "0" ]
      do    # Start of Text Word Processor Applications until loop.
#0^0^0^0^1 #MTD unoconv     - Converts any document format that LibreOffice imports/exports.
#0^0^0^24^0 #MTD wordgrinder - Word processor, styles, drop-down menus, ncurses-based.
#0^0^0^0^1 #MTD wp2x        - Converts WordPerfect 5.x documents to HTML, LaTeX, txt, troff.
#0^0^0^0^1 #MTD wpd2odt     - WordPerfect to OpenDocument converter.
#0^0^0^0^1 #MTD wpg2odg     - WordPerfect Graphics to OpenDocument converter.
#0^0^0^0^1 #MTD wps2odt     - Microsoft Works text documents to OpenDocument converter.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Text Word Processor Applications Menu"
            DELIMITER="#MTD" #MTD This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MTD
            f_menu_item_process $MTD  # Outputs $MENU_ITEM.
      done  # End of Text Word Processor Applications until loop.
            #
      unset MTD MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_text_word_processors
#
# +----------------------------------------+
# |     Function f_menu_app_text_tools     |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MTT, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_text_tools () {
      f_initvars_menu_app "MTT"
      until [ "$MTT" = "0" ]
      do    # Start of Text Tool Applications until loop.
#0^0^0^0^1     #MTT acheck    - Check grammar.
#0^0^0^0^1     #MTT aiksaurus - Thesaurus, based on Guttenburg's Moby thesaurus.
#0^0^0^0^1     #MTT antiword  - Microsoft Word document viewer/converter to txt, pdf, ps, xml.
#1^0^0^0^0     #MTT aspell    - Spell check allows text files as input with user dictionary.
#0^0^0^0^1     #MTT dict      - On-line dictionary, client application queries a dictd server.
#0^0^0^0^1     #MTT dictd     - Dictionary Server database. dict-gcide, dict-wn recommended.
#1^0^0^10:NC^0 #MTT hunspell  - Spell check allows keyboard or files as input w/user dictionary.
#1^0^0^10:NC^0 #MTT ispell    - Spell check allows text files as input with user dictionary.
#0^0^0^0^1     #MTT sdcv      - Use StarDict formatted dictionaries (must have own dictionary).
#1^0^0^10:NC^0 #MTT spell     - Spell check allows keyboard or text files as input.
#0^0^0^0^1     #MTT uniq      - Remove duplicate lines from a sorted file.
#1^0^0^0^1     #MTT wc        - Counts words, lines, characters, bytes of a text file.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="Text Tool Applications Menu"
            DELIMITER="#MTT" #MTT This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MTT
            f_menu_item_process $MTT  # Outputs $MENU_ITEM.
      done  # End of Text Tool Applications until loop.
            #
      unset MTT MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_text_tools
#
# +----------------------------------------+
# |            Function f_aspell           |
# +----------------------------------------+
#
f_aspell () {
      # If APP_NAME has no spaces, then neither [OPTIONS] nor file are specified.
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         # spell interactive mode without file name.
         clear # Blank the screen.
         echo "aspell - Spell checker lists all words that are misspelled."
         echo
         echo "Usage:" 
         echo "aspell [OPTIONS] <COMMAND> <file>..."
         echo "aspell --personal=\"My_custom_word_list\" --ignore-case check document.txt"
         echo
         echo "COMMANDS: check, create, filter, list, pipe, usage, config, dump, help, merge,"
         echo "          soundslike, version."
         echo
         echo "DICTIONARY OPTIONS"
         echo "       --personal=<file>, -p <file>"
         echo "              Personal word list file name."
         echo "       --repl=<file>"
         echo "              Replacements list file name."
         echo
         echo "CHECKER OPTIONS"
         echo "       --ignore-case, --dont-ignore-case"
         echo "              Ignore case when checking words."
         echo
         echo
         echo "*** For more help type: 'man $APP_NAME'"
         echo "                        '$APP_NAME --help'"
         echo
         echo -n "Enter name of text file to check spelling: "
         read ANS
         if [ -z $ANS ] ; then   #String has zero length.
            echo
            echo "Missing filename."
            echo "Usage: aspell check <filename>"
            echo
            # When run without a filename, usage instructions appear.
            f_press_enter_key_to_continue
         elif [ -r $ANS ] ; then   #Filename exists and is readable.
            APP_NAME="aspell -c $ANS"
         else
            echo "The file $ANS is either missing or cannot be read."
            f_press_enter_key_to_continue
         fi
      fi
} #End of function f_aspell
#
# +----------------------------------------+
# |           Function f_hunspell          |
# +----------------------------------------+
#
f_hunspell () {
      # If APP_NAME has no spaces, then neither [OPTIONS] nor file are specified.
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
           echo "hunspell - Spell checker"
         echo
         echo "Usage:"
         echo "hunspell [OPTIONS] [FILES]..."
         echo
         echo "Spell check file interactively."
         echo "hunspell -d en_US filename.txt"
         echo
         echo "Spell check file in batch mode."
         echo "cat myFile.txt | hunspell"
         echo "hunspell -l myFile.txt"
         echo
         echo "Prevent showing an '*' asterick for each line."
         echo "cat myFile.txt | hunspell -i utf-8 | grep -v \* | uniq"
         echo
         echo "List only misspelled words."
         echo "cat myFile.txt | hunspell -l -i utf-8"
         echo
         echo "*** For more help type: 'man $APP_NAME'"
         echo "                        '$APP_NAME --help'"
         echo
         echo "For interactive mode (without a text file name), just press 'Enter' key."
         echo
         echo -n "Enter name of text file to check spelling: "
         read ANS
         if [ -z $ANS ] ; then   #String has zero length.
            clear # Blank the screen.
            echo "Missing filename."
            echo "Usage: hunspell <filename>"
            echo
            echo "Since no filename, now run 'hunspell' in interactive mode."
            echo
            echo "Interactive usage:"
            echo
            echo "Example: Type the sentence below"
            echo "The wrong spelling is recieve, while the correct spelling is receive."
            echo
            echo "& recieve 8 22: receive, relieve, reprieve, retrieve, reverie, recitative,"
            echo "Recife, receivable"
            echo
            echo "The word 'recieve' is repeated on the screen because it is mis-spelled."
            echo "8=number of possible correct words."
            echo "22+1=number of characters in line until misspelled word."
            echo
            echo "Now type the word(s) or sentence to spell check."
            echo "If the word has the wrong spelling, it will be repeated on the screen."
            echo "If the word has the correct spelling, an asterick '*' will appear."
            echo
         elif [ -r $ANS ] ; then   #Filename exists and is readable.
            APP_NAME="hunspell $ANS"
         else
            echo "The file $ANS is either missing or cannot be read."
            echo "Entering interactive mode."
            f_press_enter_key_to_continue
         fi
      fi
} # End of function f_hunspell
#
# +----------------------------------------+
# |            Function f_ispell           |
# +----------------------------------------+
#
f_ispell () {
      # If APP_NAME has no spaces, then neither [OPTIONS] nor file are specified.
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "ispell - Spell checker"
         echo
         echo "Usage:" 
         echo "ispell [OPTIONS] <COMMAND> ..."
         echo
         echo "Related packages:" 
         echo "iamerican, iamerican-small, -large, -huge, -insane"
         echo "ibritish, ibritish-small, -large, -huge, -insane"
         echo
         echo "*** For more help type: 'man $APP_NAME'"
         echo "                        '$APP_NAME --help'"
         echo
         echo "Ispell application lists all words that are misspelled."
         echo
         echo "For interactive mode (without a text file name), just press 'Enter' key."
         echo
         echo -n "Enter name of text file to check spelling: "
         read ANS
         if [ -z $ANS ] ; then   #String has zero length.
            echo
            echo "Missing filename."
            echo "Usage: ispell <filename>"
            echo
            f_press_enter_key_to_continue
         elif [ -r $ANS ] ; then   #Filename exists and is readable.
            APP_NAME="ispell $ANS"
         else
            echo "The file $ANS is either missing or cannot be read."
            echo "Entering interactive mode."
            f_press_enter_key_to_continue
         fi
      fi
} # End of function f_ispell
#
# +----------------------------------------+
# |            Function f_spell            |
# +----------------------------------------+
#
f_spell () {

      # If APP_NAME has no spaces, then neither [OPTIONS] nor file are specified.
      if [[ ! "$APP_NAME" == *" "* ]] ; then
      # spell interactive mode without file name.
         clear # Blank the screen.
         echo "spell - Spell checker"
         echo
         echo "Usage:"
         echo "spell [OPTIONS] [FILE] ..."
         echo
         echo "*** For more help type: 'man $APP_NAME'"
         echo "                        '$APP_NAME --help'"
         echo
         echo "Spell application lists all words that are misspelled."
         echo
         echo "For interactive mode (without a text file name), just press 'Enter' key."
         echo
         echo -n "Enter name of text file to check spelling: "
         read ANS
         if [ -z $ANS ] ; then   #String has zero length.
            clear # Blank the screen.
            echo "Missing filename."
            echo "Usage: spell <filename>"
            echo
            echo "Since no filename, now run 'spell' in interactive mode."
            echo
            echo "Interactive usage:"
            echo
            echo "Example: Type the sentence below"
            echo "The wrong spelling is recieve, while the correct spelling is receive"
            echo
            echo "recieve <<--spell responds with this word."
            echo
            echo "The word 'recieve' is repeated on the screen because it is mis-spelled."
            echo
            echo "Now type the word(s) or sentence to spell check."
            echo
            echo "If the word has the wrong spelling, it will be repeated on the screen."
            echo "If the word has the correct spelling, it will not be repeated."
            echo
            f_how_to_quit_application "<Ctrl>-D" "no-clear"
            APP_NAME="spell"
         elif [ -r $ANS ] ; then   #Filename exists and is readable.
            APP_NAME="spell $ANS"
            f_application_run
         else
            echo "The file $ANS is either missing or cannot be read."
            echo "Entering interactive mode."
            f_press_enter_key_to_continue
         fi
      else
         # spell non-interactive mode with file name.
         f_press_enter_key_to_continue 
      fi
} # End of function f_spell
#
# +----------------------------------------+
# |              Function f_wc             |
# +----------------------------------------+
#
f_wc () {
      # If APP_NAME has no spaces, then neither [OPTIONS] nor file are specified.
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         APP_NAME="wc"
         clear # Blank the screen.
         echo "wc - Word Count"
         echo
         echo "Usage:"
         echo "wc [OPTIONS] [FILE]..."
         echo
         echo "-c, --bytes      prints the byte counts."
         echo "-m, --chars      prints the character counts."
         echo "-l  --lines      prints the new line counts."
         echo "-w  --words      prints the word counts."
         echo
         echo "Example: Type the sentences below"
         echo "Line 1 This is the first line."
         echo "Line 2 This is the second Line."
         echo "      2      14      63"
         echo "    Lines   Words   Characters"
         echo
         echo
         echo "*** For more help type: 'man $APP_NAME'"
         echo "                        '$APP_NAME --help'"
         echo
         echo -n "Enter name of text file to check spelling: "
         read ANS
         if [ -z $ANS ] ; then   #String has zero length.
            clear # Blank the screen.
            echo "Missing filename."
            echo "Usage: wc <filename>"
            echo
            echo "Since no filename, now run '' in interactive mode."
            echo
            echo "Interactive usage:"
            echo
            echo "Example: Type the sentences below"
            echo "Line 1 This is the first line."
            echo "Line 2 This is the second Line."
            echo "      2      14      63"
            echo "    Lines   Words   Characters"
            echo
            f_how_to_quit_application "<Ctrl>-D" "no-clear"
            APP_NAME="wc"
            f_application_run
            PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
         elif [ -r $ANS ] ; then   #Filename exists and is readable.
            APP_NAME="wc $ANS"
            f_application_run
         else
            echo "The file $ANS is either missing or cannot be read."
            echo "Entering interactive mode."
            f_press_enter_key_to_continue
         fi
       fi
} # End of function f_wc
#
# +----------------------------------------+
# |        Function f_menu_app_todo        |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MTA, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_todo () {
      f_initvars_menu_app "MTA"
      until [ "$MTA" = "0" ]
      do    # Start of ToDo Applications until loop.
#0^0^0^1^0  #MTA beeswax  - To-Do List.
#0^0^0^1^0  #MTA calcurse - Calendar and To-Do List; ncurses-based.
#0^0^0^0^1  #MTA diary    - Diary & To-Do List uses grep, date, etc. with your text editor.
#0^0^0^0^1  #MTA diary-f  - Fork of "diary" enhanced "view"/"cat", non-latin locales.
#0^0^0^0^1  #MTA doneyet  - To-Do List.
#0^0^0^0^1  #MTA etm      - Event and task manager.
#0^0^0^0^0  #MTA hnb      - To-Do List and note taker, ncurses-based application.
#0^0^0^0^1  #MTA ikog     - To-Do List
#0^0^0^0^1  #MTA org-mode - Emacs plugin for notes, To-Do lists, and project planning.
#0^0^0^0^1  #MTA task     - Taskwarrior To-Do lists synchronize multiple PCs.
#0^0^0^21^0 #MTA tdl      - To-Do List manager.
#1^0^0^0^0  #MTA todo     - To-Do List hierarchical. Install package "devtodo".
#1^0^0^0^0  #MTA todo2    - "devtodo2" application is a todo2 list, 5-levels of priorties.
#0^0^0^0^0  #MTA tudu     - To-Do List hierarchical tasks.
#0^0^0^0^1  #MTA w2do     - To-Do with support for group, due date and priority categories.
#f_menu_app_todo2^0^0^0^0 #MTA MORE...  - More To-Do applications.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="To-Do Applications Menu"
            DELIMITER="#MTA" #MTA This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MTA
            f_menu_item_process $MTA  # Outputs $MENU_ITEM.
      done  # End of ToDo Applications until loop.
            #
      unset MTA MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_todo
#
# +----------------------------------------+
# |        Function f_menu_app_todo2       |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MTB, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_todo2 () {
      f_initvars_menu_app "MTB"
      until [ "$MTB" = "0" ]
      do    # Start of ToDo2 Applications until loop.
#0^0^0^0^1  #MTB yaGTD    - To-Do List based on "Getting Things Done" methodology.
#0^0^0^0^0  #MTB yokadi   - Project/task manager which uses SQLite.
            #
            THIS_FILE="mod_apps-office.lib"
            MENU_TITLE="To-Do2 Applications Menu"
            DELIMITER="#MTB" #MTB This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MTB
            f_menu_item_process $MTB  # Outputs $MENU_ITEM.
      done  # End of ToDo2 Applications until loop.
            #
      unset MTB MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_todo2
#
# +----------------------------------------+
# |             Function f_todo            |
# +----------------------------------------+
#
f_todo () {
      clear # Blank the screen.
      echo "todo - Simple To-Do list using hidden file .todo as a database list."
      echo
      echo "todo [OPTIONS]"
      echo "       With no options, displays the items in the current directory."
      echo
      echo "tda [-p <priority>] [-g <index>] [<text>]"
      echo "      Add a new item, optionally grafting it as a child of the given item."
      echo "tde <index>"
      echo "     Edit the given item."
      echo "tdr <indices>"
      echo "     Remove the given items."
      echo "tdd <indices>"
      echo "     Mark the specified items as being done."
      echo
      echo "*** For more help type: 'man todo'"
      echo "                        'todo --help'"
      echo
      echo "todo -a to add a new note, todo -A -all to show all notes."
      echo 
      echo "Now run todo. Usage: todo"
      f_press_enter_key_to_continue
} # End of function f_todo
#
# +----------------------------------------+
# |             Function f_todo2           |
# +----------------------------------------+
#
f_todo2 () {
      clear # Blank the screen.
      echo "devtodo2 - To-Do list with 5-levels of priorities."
      echo
      echo "***Note: Run using 'todo2' command.***"
      echo "         Application name is devtodo2".
      echo
      echo "todo2 [OPTIONS]"
      echo "       With no options, displays the items in the current directory."
      echo
      echo "Add a Task:"
      echo "todo2 -a <Task description> "
      echo            
      echo "Add a task as a child of an existing task:"
      echo "todo2 -g 2 -a This is a child of task 2."
      echo
      echo "List all tasks:"
      echo "todo2 -A"
      echo
      echo "Mark a task as complete:"
      echo "todo2 -d 1.2"
      echo
      echo "*** For more help type: 'man todo2'"
      echo "                        'todo2 --help'"
      echo
      echo "Now run devtodo2. Usage: todo2"
      f_press_enter_key_to_continue
} # End of function f_todo2
#
